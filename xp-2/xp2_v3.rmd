---
title: "Perception of difficulty with Random Curve"
output:
  html_document:
    theme: lumen
  word_document: default
  pdf_document: default
---
```{r global.infos, echo=FALSE}

# risk aversion scores
# 0-1 : highly risk loving
#  2  : very risk loving
#  3  : risk loving
#  4  : risk neutral
#  5  : slightly risk averse
#  6  : risk averse
#  7  : very risk averse
#  8  : highly risk avers
# 9-10 : max choix sûr

# self efficacy scores
# 0 : not a player so did not answer
# de 10 à 20 : sentiment AE faible
# de 21 à 30 : sentiment AE moyen
# de 31 à 40 : sentiment AE fort
# de 41 à 50 : sentiment AE très fort

```

```{r setup, include = FALSE}

#------------------------------------------------------
#                  SETUP : PACKAGES
#------------------------------------------------------
require(xlsx)
require(plyr)
require(data.table)
require(ggplot2)
library(car)
require(lme4)
require(lmerTest)
require(Matrix)
library(usdm)
require(lattice)
require(psychometric)
require(MuMIn)
require(pyramid)
require(sjPlot)
require(arm)
library(MASS)
require(Hmisc)
require(RColorBrewer)

#------------------------------------------------------
#              SETUP : UTILS FUNCTIONS
#------------------------------------------------------
format.pval.stars <- function(pv){
  pv = signif(pv,digits=2)
  if(pv<0.001) {
    return(paste(pv,"***"));
  }else if(pv<0.01){ 
    return(paste(pv,"**"));
  }else  if(pv<0.05){ 
    return(paste(pv,"*"));
  }else if(pv<0.1){ 
    return(paste(pv,"."));
  }else{
    return(paste(pv,":("));
  }
  return("unable to format pvalue !!");
}

format.pval.only.stars <- function(pv){
  pv = signif(pv,digits=2)
  if(pv<0.001) {
    return("***");
  }else if(pv<0.01){ 
    return("**");
  }else  if(pv<0.05){ 
    return("*");
  }else if(pv<0.1){ 
    return(".");
  }else{
    return(":(");
  }
  return("unable to format pvalue !!");
}

format.coef <- function(coef,p.val){
  return(paste(signif(coef,digits=3),format.pval.stars(p.val)))
}

remove.na.cols <- function(DT){
  return(as.data.table(DT[,which(unlist(lapply(DT, function(x)!all(is.na(x))))),with=F]))
}
remove.na.rows <- function(DT){
  return(as.data.table(DT[rowSums(is.na(DT)) != ncol(DT),]))
}
set.empty.to.na <- function(DT){
  return(as.data.table(lapply(DT, function(x){replace(x, x=="",NA)})))
}

remove.head.tail <- function(DT,nb,bHead=TRUE){
  DT <- as.data.table(DT)
  setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
  if(bHead)
    DT <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
  else
    DT <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
  return(DT)
}

#Plot la courbe de diff pour un joueur avec la BET
plot.diff.curve <- function (DT,title){
  if(nrow(DT) == 0)
    return()
  df <- data.frame(time=DT$action_de_jeu,
                   difficulty=DT$difficulty,
                   bet=DT$miseNorm,
                   confidence=DT$confianceNorm)
  
  p <- ggplot(df,aes(x=time)) 
  
  p <- p + geom_step(aes(y=bet,colour="Mise"))
  p <- p + geom_step(aes(y=confidence,colour="Confiance"))
  
  if(length(DT$obj.diff) > 0)
    p <- p + geom_step(aes(y=DT$obj.diff,colour="Difficulté objective"))
  else
    p <- p + geom_step(aes(y=difficulty,colour="Paramètre de difficulté"))
 
   p <- p + ylim(0, 1)
  p <- p + scale_colour_manual(
    values = c("Paramètre de difficulté" = "red",
               "Difficulté objective" = "pink",
               "Mise" = "blue",
               "Confiance" = "cyan"))
  p <- p  +  ggtitle(title);
  print(p)  
}
```

```{r globals.variables, echo = FALSE}
#------------------------------------------------------
#                  GLOBAL VARIABLES
#------------------------------------------------------
g.ignore.confidence.scale.outilers <- FALSE
p <- g.ignore.confidence.scale.outilers
cat("Ignorer les outliers relatifs à l'utilisation de l'échelle de confiance : ", p)

g.use.confiance <- FALSE
p <- g.use.confiance
cat("Résultats basés sur la l'échelle de confiance : ", g.use.confiance)

g.short.version <- FALSE
cat("Version courte : ", g.short.version)

g.withplayerprofiles.version <- TRUE
cat("Avec analyse des profils de joueurs : ", g.withplayerprofiles.version)
```

```{r data.loading, echo=FALSE}
#------------------------------------------------------
#                  LOADING DATA
#------------------------------------------------------

# Data from game trace
fileGameTrace = "data/xp2_game.csv" 
DTGameXp2 <- read.csv(fileGameTrace,header=TRUE,sep=";")
DTGameXp2 <- as.data.table(DTGameXp2)
DTGameXp2 <- set.empty.to.na(DTGameXp2)
DTGameXp2 <- remove.na.cols(DTGameXp2)
DTGameXp2 <- remove.na.rows(DTGameXp2)
DTGameXp2[,gameDiff:=NULL] #que dans xp2 et inutilisé
DTGameXp2[,near_miss:=NULL] #que dans xp2 et inutilisé
DTGameXp2 <- subset(DTGameXp2, modeTest!=1) #on enleve les tours de chauffe (marqués dans cette xp)
DTGameXp2 <- subset(DTGameXp2, action_de_jeu!=1) # Removing the first turn (where difficulty == 0)
DTGameXp2[,modeTest:=NULL] #plus utile
DTGameXp2$random_diff=1;

fileGameTrace =  "data/xp1_game_week2.txt" #résultats jeux XP CN2 avec diff DDA
DTGameXp1 <- read.csv(fileGameTrace,header=TRUE,sep=";")
DTGameXp1 <- as.data.table(DTGameXp1)
DTGameXp1 <- set.empty.to.na(DTGameXp1)
DTGameXp1 <- remove.na.cols(DTGameXp1)
DTGameXp1 <- remove.na.rows(DTGameXp1)
DTGameXp1$random_diff=0;

DTGame <- merge(DTGameXp2,DTGameXp1, all=TRUE) #pour n'avoir que les données tirées du jeu

# Data from questionnaire
fileQuestions = "data/xp2_questionnaire.csv"
DTQuestXp2 <- read.csv(fileQuestions,header=TRUE,sep=";")
DTQuestXp2 <- as.data.table(DTQuestXp2)
DTQuestXp2 <- set.empty.to.na(DTQuestXp2)
DTQuestXp2 <- remove.na.cols(DTQuestXp2)
DTQuestXp2 <- remove.na.rows(DTQuestXp2)
#DTQuestXp2$random_diff=1;

fileQuestions = "data/xp1_questionnaire.csv"
DTQuestXp1 <- read.csv(fileQuestions,header=TRUE,sep=";")
DTQuestXp1 <- as.data.table(DTQuestXp1)
DTQuestXp1 <- set.empty.to.na(DTQuestXp1)
DTQuestXp1 <- remove.na.cols(DTQuestXp1)
DTQuestXp1 <- remove.na.rows(DTQuestXp1)
#DTQuestXp1$random_diff=0;

DTQuest <- merge(DTQuestXp2,DTQuestXp1, all=TRUE) #pour n'avoir que les données tirées du questionnaire

# Merging tables into one
setkey(DTGame,IDjoueur)
setkey(DTQuest,IDjoueur)
DTAll <- merge(DTGame,DTQuest, all.x=TRUE)

```


```{r questionnaire.variables, echo=FALSE}
#------------------------------------------------------
#         ADDING VARIABLES FOR QUESTIONNAIRE
#------------------------------------------------------

# how much playing video games in general
DTAll$play.video.games = pmax(DTAll$profilJoueur2,
                              DTAll$profilJoueur3,
                              DTAll$profilJoueur4,
                              DTAll$profilJoueur5,
                              DTAll$profilJoueur6)
DTAll$play.video.games = DTAll$play.video.games / max(DTAll$play.video.games)

# how much playing board games
DTAll$play.board.games = pmax(DTAll$profilJoueur1)
DTAll$play.board.games = DTAll$play.board.games / max(DTAll$play.board.games)

# how much playing games with money
DTAll$play.money.games = pmax(DTAll$profilJoueur7)
DTAll$play.money.games = DTAll$play.money.games / max(DTAll$play.money.games)

DTAll <- DTAll[,c("profilJoueur1","profilJoueur2","profilJoueur3","profilJoueur4",
                   "profilJoueur5","profilJoueur6","profilJoueur7"):=NULL] #dont need them anymore

# feeling of self efficacy
cols.self.eff <- c("autoEffJoueur1","autoEffJoueur2","autoEffJoueur3","autoEffJoueur4",
                   "autoEffJoueur5","autoEffJoueur6","autoEffJoueur7","autoEffJoueur8",
                   "autoEffJoueur9","autoEffJoueur10")
DTAll = DTAll[, self.eff := rowSums(.SD,na.rm=TRUE), .SDcols = cols.self.eff]
DTAll$self.eff = DTAll$self.eff/10
DTAll[profilJoueur8==0,self.eff := NA] #NA tout ceux qui ne jouaient pas au jeu vidéo 
DTAll <- DTAll[,c("autoEffJoueur1","autoEffJoueur2","autoEffJoueur3","autoEffJoueur4",
                   "autoEffJoueur5","autoEffJoueur6","autoEffJoueur7","autoEffJoueur8",
                   "autoEffJoueur9","autoEffJoueur10","profilJoueur8"):=NULL] #dont need them anymore

# risk aversion
cols.risk.av <- c("loterie1","loterie2","loterie3","loterie4","loterie5",
                  "loterie6","loterie7","loterie8","loterie9","loterie10")
DTAll = DTAll[, risk.av := rowSums(.SD,na.rm=TRUE), .SDcols = cols.risk.av]
DTAll$risk.av = DTAll$risk.av/10
DTAll <- DTAll[,c("loterie1","loterie2","loterie3","loterie4","loterie5",
                  "loterie6","loterie7","loterie8","loterie9","loterie10"):=NULL] #dont need them anymore

# Printing data from players
DTQuestLit <- subset(DTQuest, select=c("IDjoueur"))
p <- nrow(DTQuestLit)
cat("Nombre de participants à l'expérimentation : ", p)
#===#
DTQuestLit <- subset(DTQuest, select=c("IDjoueur","sexe", "profilJoueur8"))
p <- nrow(DTQuestLit[profilJoueur8==1])
cat("Nombre de participants se déclarant comme joueurs : ", p)
#===#
p <- DTQuestLit[ which( DTQuestLit$profilJoueur8 == 1 & DTQuestLit$sexe == 1) , ]
p <- nrow(p[profilJoueur8==1])
cat("Nombre de femmes se déclarant comme joueuses : ", p)
#===#
DTQuestAge <- subset(DTQuest, select=c("age"))
prout <- as.numeric(DTQuestAge$age)
p <- median(DTQuestAge$age, na.rm = T)
cat("Age médian des joueurs : ", p)

# clear not used data
DTAll <- DTAll[,c("jeuxFav","horodateur","prenomNom"):=NULL] #dont need them at all

```

```{r game.traces.simple.variables, echo=FALSE}
#------------------------------------------------------
#         ADDING SIMPLE VARIABLES FOR GAME TRACES
#------------------------------------------------------

DTAll$perdant <- 1-DTAll$gagnant # if the player did fail on that try
DTAll$miseNorm <- DTAll$mise / 7 # normalize bet
DTAll$timeNorm <- DTAll$action_de_jeu / max(DTAll$action_de_jeu) #normalise, to compare
DTAll$confianceNorm <- DTAll$confiance / 100 #normalize player's confidence
 
#number of consecutive fails
gagnant = DTAll$gagnant; # tmp vector faster to read
id = DTAll$IDjoueur; # tmp vector faster to read
nbFails <- numeric(nrow(DTAll)) # tmp vector faster to write
nbFails[1] = 0;
nbFailCpt = 0;
lastID <- id[1];
for(i in 2:nrow(DTAll)){
  if(id[i] != lastID){
    nbFailCpt = 0;
  }else{
    if(gagnant[i-1] == 0){
      nbFailCpt = nbFailCpt+1;
    }else{
      nbFailCpt = 0;
    }
  }
  nbFails[i] <- nbFailCpt;
  lastID = id[i-1];
}
  
DTAll$nbFail = nbFails;

#number of consecutive wins
nbWins <- numeric(nrow(DTAll)) # tmp vector faster to write
nbWins[1] = 0;
nbWinCpt = 0;
lastID <- id[1];
for(i in 2:nrow(DTAll)){
  if(id[i] != lastID){
    nbWinCpt = 0;
  }else{
    if(gagnant[i-1] == 1){
      nbWinCpt = nbWinCpt+1;
    }else{
      nbWinCpt = 0;
    }
  }
  nbWins[i] <- nbWinCpt;
  lastID = id[i-1];
}
  
DTAll$nbWin = nbWins;

#sum of absolute bet variation over time, mainly to spot 1/7/1/7/1/7 behaviors
mise = DTAll$mise;
cumulDeltaMise <- numeric(nrow(DTAll))
cumulDeltaMise[1] = 0;
lastID <- id[1];
currentCumulDeltaMise = 0;
for(i in 2:nrow(DTAll)){
  if(id[i] != lastID){
    currentCumulDeltaMise = 0;
  }else{
    currentCumulDeltaMise = currentCumulDeltaMise + abs(mise[i] - mise[i-1]);
  }
  lastID = id[i];
  cumulDeltaMise[i] = currentCumulDeltaMise;
}

DTAll$cumulDeltaMise = cumulDeltaMise;
```

# Removing Outliers 

```{r removing.outliers.setup, echo=FALSE}
 #------------------------------------------------------
 #            OUTLIERS SETUP
 #------------------------------------------------------
 
 DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
 DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
 DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]
 
 
 get.outliers <- function(DTDescMLoc,DTDescSLoc,DTDescLLoc){
   outliersM <- boxplot.stats(DTDescMLoc$var)$out
   outliersS <- boxplot.stats(DTDescSLoc$var)$out
   outliersL <- boxplot.stats(DTDescLLoc$var)$out
   
   outliers = data.table(type=character(0),id=character(0))
   setkey(outliers,id)
   if(length(outliersM) > 0)
     outliers = merge(outliers,data.table(id=DTDescMLoc[var %in% outliersM]$IDjoueur,type="Moteur"),by=c("id","type"),all=TRUE)
   if(length(outliersS) > 0)
     outliers = merge(outliers,data.table(id=DTDescSLoc[var %in% outliersS]$IDjoueur,type="Sensoriel"),by=c("id","type"),all=TRUE)
   if(length(outliersL) > 0)
     outliers = merge(outliers,data.table(id=DTDescLLoc[var %in% outliersL]$IDjoueur,type="Logique"),by=c("id","type"),all=TRUE)
     
   return(outliers)
 }
 
 plot.outliers <- function(DT,title){
   p <- ggplot(DT, 
             aes(type,var)) + 
             xlab("Difficulty Type") + 
             ylab(title)
   p <- p + geom_boxplot() + geom_point(shape=1) 
   print(p)
 }
```
 
```{r detect.outliers.sd, echo=FALSE}
 #------------------------------------------------------
 #            OUTLIERS BET STD DEV
 #------------------------------------------------------
if (g.ignore.confidence.scale.outilers == TRUE) {
  DTDescM = DTM[,.(type="Moteur",var=sd(miseNorm)),by=IDjoueur]
  DTDescS = DTS[,.(type="Sensoriel",var=sd(miseNorm)),by=IDjoueur]
  DTDescL = DTL[,.(type="Logique",var=sd(miseNorm)),by=IDjoueur]
 
  if(g.short.version == FALSE)
     plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Bet Standard Dev");
 
  outliers = get.outliers(DTDescM,DTDescS,DTDescL)
  print(paste("Outliers BET STANDARD DEVIATION:",toString(outliers$id)))
 
  DTM[IDjoueur %in% unlist(outliers[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Motor Task");NULL},by=.(IDjoueur)]
  DTS[IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Sensory Task");NULL},by=.(IDjoueur)]
  DTL[IDjoueur %in% unlist(outliers[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Logical Task");NULL},by=.(IDjoueur)]
} 
```
 
```{r detect.outliers.win.sum, echo=FALSE}
 #------------------------------------------------------
 #            OUTLIERS SUM OF WINS
 #------------------------------------------------------
 # Difficulty : win sum
 
 # DTDescM = DTM[,.(type="Moteur",var=sum(gagnant)),by=IDjoueur]
 # DTDescS = DTS[,.(type="Sensoriel",var=sum(gagnant)),by=IDjoueur]
 # DTDescL = DTL[,.(type="Logique",var=sum(gagnant)),by=IDjoueur]
 # 
 # plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Win Sum");
 # 
 # outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
 # outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
 # print(paste("Outliers :",toString(outliersLoc$id)))
 # 
 # DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Motor Task");NULL},by=.(IDjoueur)]
 # DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Sensory Task");NULL},by=.(IDjoueur)]
 # DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Logical Task");NULL},by=.(IDjoueur)]
 
```
 
```{r detect.outliers.sheeps.saved, echo=FALSE}
 #------------------------------------------------------
 #            OUTLIERS SAVED SHEEPS
 #------------------------------------------------------
 # Difficulty and strategy = saved sheeps
 DTDescM = DTM[,.(type="Moteur",var=max(moutons_sauves)),by=IDjoueur]
 DTDescS = DTS[,.(type="Sensoriel",var=max(moutons_sauves)),by=IDjoueur]
 DTDescL = DTL[,.(type="Logique",var=max(moutons_sauves)),by=IDjoueur]
 
 if(g.short.version == FALSE)
   plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Saved sheeps");
 
 outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
 if(exists("outliers")){
   outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
 } else {
   outliers = outliersLoc
 }
   
 print(paste("Outliers BET SAVED SHEEPS:",toString(outliersLoc$id)))
 
 DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Score Motor Task");NULL},by=.(IDjoueur)]
 DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Score Sensory Task");NULL},by=.(IDjoueur)]
 DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Score Logical Task");NULL},by=.(IDjoueur)]
 
```
 
```{r detect.outliers.cs.sd, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS CS STD DEV
#------------------------------------------------------
if(g.ignore.confidence.scale.outilers){
  DTDescM = DTM[,.(type="Moteur",var=sd(confianceNorm)),by=IDjoueur]
  DTDescS = DTS[,.(type="Sensoriel",var=sd(confianceNorm)),by=IDjoueur]
  DTDescL = DTL[,.(type="Logique",var=sd(confianceNorm)),by=IDjoueur]
  
  if(g.short.version == FALSE)
    plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "CS Standard Dev");
  
  outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
  outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
  
  print(paste("Outliers CS STANDARD DEVIATION:",toString(outliers$id)))
  
  DTM[IDjoueur %in% unlist(outliers[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier CS Sd Motor Task");NULL},by=.(IDjoueur)]
  DTS[IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier CS Sd Sensory Task");NULL},by=.(IDjoueur)]
  DTL[IDjoueur %in% unlist(outliers[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier CS Sd Logical Task");NULL},by=.(IDjoueur)]  
}
```

```{r detect.outliers.cs.null, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS CS NULL
#------------------------------------------------------
if(g.ignore.confidence.scale.outilers){
  DTDescM = DTM[,.(type="Moteur",var=(sum(confianceNorm!=confianceNorm[1])>0)*1),by=IDjoueur]
  DTDescS = DTS[,.(type="Sensoriel",var=(sum(confianceNorm!=confianceNorm[1])>0)*1),by=IDjoueur]
  DTDescL = DTL[,.(type="Logique",var=(sum(confianceNorm!=confianceNorm[1])>0)*1),by=IDjoueur]
  
  if(g.short.version == FALSE)
    plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "CS null");
  
  outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
  outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
  print(paste("Outliers CS NULL:",toString(outliers$id)))
  
  DTM[IDjoueur %in% unlist(outliers[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier CS Null Motor Task");NULL},by=.(IDjoueur)]
  DTS[IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier CS Null Sensory Task");NULL},by=.(IDjoueur)]
  DTL[IDjoueur %in% unlist(outliers[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier CS Null Logical Task");NULL},by=.(IDjoueur)]
}
``` 
 
 
```{r outliers.summary, echo=FALSE}
 #------------------------------------------------------
 #            OUTLIERS SUMMARY
 #------------------------------------------------------
 print(paste("Total number of participants : ",toString(nrow(unique(DTAll,by="IDjoueur")))))
 print(paste("Total number of outliers: ",toString(nrow(unique(outliers,by="id")))))
 print(paste("- total number of outliers motor task: ",toString(nrow(unique(outliers[type=="Moteur"],by="id")))))
 print(paste("- total number of outliers perceptive task: ",toString(nrow(unique(outliers[type=="Logique"],by="id")))))
 print(paste("- total number of outliers logical task: ",toString(nrow(unique(outliers[type=="Sensoriel"],by="id")))))
```
 
```{r remove.outliers, echo=FALSE}
 #------------------------------------------------------
 #            REMOVING OUTLIERS FROM TABLES
 #------------------------------------------------------
 # removing all outliers
 DTM <- DTM[!IDjoueur %in% unlist(outliers[type=="Moteur"]$id)]
 DTS <- DTS[!IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id)]
 DTL <- DTL[!IDjoueur %in% unlist(outliers[type=="Logique"]$id)]
 DTAll <- data.table()
 DTAll <- rbind(DTAll,DTL)
 DTAll <- rbind(DTAll,DTM)
 DTAll <- rbind(DTAll,DTS)
 print(paste("Total number of participants after removing outliers: ",toString(nrow(unique(DTAll,by="IDjoueur")))))
 print(paste("- motor: ",toString(nrow(unique(DTM,by="IDjoueur")))))
 print(paste("- perceptive: ",toString(nrow(unique(DTS,by="IDjoueur")))))
 print(paste("- logical: ",toString(nrow(unique(DTL,by="IDjoueur")))))
 
```

# Modeling difficulty

```{r modeling.difficulty.compute.utils, echo=FALSE}
#------------------------------------------------------
#            MODELING OBJECTIVE DIFFICULTY 
#------------------------------------------------------
#modeling difficulty as mixed effect linear model
model.objective.diff <- function(DT){
  model <- glmer(perdant ~ difficulty + timeNorm + (1 | IDjoueur), DT,family = "binomial"(link = "logit"))
  
  #On met ici le vrai nom de la variable passée en argument genre DTM ou DTL car sinon, quand
  #on calcule le r2 du modele, il doit accéder aux datas. Et dans le modèle, il a stoqué DTM, qui
  #est une variable locale à cette fonction. Et donc il ne la retrouve pas et plante. Donc on va 
  #chercher le nom de la variable et on le met de force. An oter que c'est le meme soucis pour ce qu'il
  #y a dans formula mais on a pas touché 
  #https://stackoverflow.com/questions/14275664/how-to-use-lmer-inside-a-function
  dtname <- as.name(deparse(substitute(DT)))
  model@call$data <- dtname
  return(model)
}

add.diff.obj <- function (DT,fit){
  sample = data.frame(difficulty=DT$difficulty, IDjoueur=DT$IDjoueur, timeNorm=DT$timeNorm)
  DT$obj.diff =  predict(fit, newdata = sample, type = "response")
  return (DT)
}

#cross val difficulty model
get.model.accuracy <- function(DT){
  DT$cross.val.group = round(runif(nrow(DT),0.5,10.5))
  totAccuracy <- 0
  for(i in 1:10){
    DTModel <-  DT[cross.val.group != i]
    DTTest <- DT[cross.val.group == i]
    fit <- model.objective.diff(DTModel)
    newres = predict(fit, newdata = DTTest, type = "response")  
    newres = round(newres)
    accuracy = abs(newres - DTTest$perdant)
    localAccu = table(accuracy)[[1]]/length(accuracy)
    totAccuracy <-  totAccuracy + localAccu
    #print(localAccu)
  }
  
  totAccuracy = totAccuracy / 10
  return (totAccuracy)
}

get.levels <- function(DT,fit){
  fit.ranef = ranef(fit)$IDjoueur
  DTLevel <- data.table(IDjoueur=rownames(fit.ranef),niveau=-fit.ranef); # ! minus, cause it's a level
  setnames(DTLevel,"niveau.(Intercept)","niveau")
  return(DTLevel)
}

add.levels <- function(DT,fit){
  DTLevel <- get.levels(DT,fit)
  return(merge(DT,DTLevel,by="IDjoueur",all=T))
} 

#TODO par groupe
add.levels.groups<- function(DT){
  #fit = hclust(dist(DT$niveau), "ward.D2")
  #plot(fit,hang=-1)
  #groups <- cutree(fit, k=3) 
  nbJoueur <- nrow(unique(DT,by="niveau"))
  fit<-kmeans(DT$niveau,min(nbJoueur,3))
  groups<-fit$cluster
  DT$niveau.group = factor(groups)
  levels.order = DT[order(niveau),.(ordered.group=niveau.group),by=niveau.group]
  levels.factors = levels(factor(c("bad","medium","good"),levels=c("bad","medium","good"),ordered=T))
  
  levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[1]$niveau.group] <- levels.factors[1]
  levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[2]$niveau.group] <- levels.factors[2]
  levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[3]$niveau.group] <- levels.factors[3]

  return(DT)
}
```

```{r modeling.difficulty.draw.utils, echo=FALSE}
#------------------------------------------------------
#         SHOWING OBJECTIVE DIFFICULTY 
#------------------------------------------------------
print.objective.diff.model <- function (DT,fit) {
  print(summary(fit))
  
  fit.ranef = ranef(fit)$IDjoueur
  fit.sum = unlist(summary(fit))
  inter = fit.sum$coefficients1
  beta.diff = fit.sum$coefficients2
  beta.time = fit.sum$coefficients3
  inter.p.val = fit.sum$coefficients10
  beta.diff.p.val = fit.sum$coefficients11
  beta.time.p.val = fit.sum$coefficients12
  fit.r.value.fix = r.squaredGLMM(fit)[1,1] #R2 for fixed effect model. MuMIn 1.41.0 resultat en matrice. 
  fit.r.value.mix = r.squaredGLMM(fit)[1,2] #R2 for mixed effect model  MuMIn 1.41.0 resultat en matrice. 
  fit.cross.val = get.model.accuracy(DT)
  fit.aic = AIC(fit)
  
  print(table(DT$nom_du_jeu))
  print("Player levels from ranef:")
  print(summary(fit.ranef))
  print(paste("Intercept:",format.coef(inter,inter.p.val)))
  print(paste("Difficulty:",format.coef(beta.diff,beta.diff.p.val)))
  print(paste("Time:",format.coef(beta.time,beta.time.p.val)))
  print(paste("R2 fixed:",signif(fit.r.value.fix,digits=2)))
  print(paste("R2 mixed:",signif(fit.r.value.mix,digits=2)))
  print(paste("Cross Val:",signif(fit.cross.val,digits=2)))
  print(paste("AIC:",signif(fit.aic,digits=2)))
}

plot.objective.diff.model.curves <- function (DT,fit,time=1,groups=T, randomDiff=1) {

  DT = DT[random_diff == randomDiff ]
  #DTLevel <- get.levels(DT,fit)
  DTLevel <- unique(DT,by="IDjoueur")
  if(groups){
    DTLevel[niveau.group=="bad",group.color:=as.character("yellow")]
    DTLevel[niveau.group=="medium",group.color:=as.character("cyan")]
    DTLevel[niveau.group=="good",group.color:=as.character("green")]
  }else{
    DTLevel[niveau.group=="bad",group.color:=as.character("black")]
    DTLevel[niveau.group=="medium",group.color:=as.character("black")]
    DTLevel[niveau.group=="good",group.color:=as.character("black")]
  }
  
  for(i in 1:nrow(DTLevel)){
    sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=DTLevel[i]$IDjoueur, timeNorm=time)#TODO plusieurs temps
    newres = predict(fit, newdata = sample, type = "response")
    DT = data.table(difficulty=seq(0, 1, 0.05),
                    IDjoueur = DTLevel[i]$IDjoueur, 
                    estDiff = newres,  
                    group.color = DTLevel[i]$group.color)
    if(i==1){
      p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 0.2,colour=DT$group.color) + xlim(0,1) + ylim(0,1)
    } else {
      p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 0.2,size=1,colour=DT$group.color)
    }
  }
  
  DTLevel = DTLevel[order(abs(niveau))];
  joueurMed = DTLevel[1]$IDjoueur
  
  level.quants = quantile(DTLevel$niveau,probs = seq(0, 1, 0.25))
  print(level.quants)
  DTLevel = DTLevel[order(abs(niveau - (level.quants[2])))];
  joueurMin = DTLevel[1]$IDjoueur
  DTLevel = DTLevel[order(abs(niveau - (level.quants[4])))];
  joueurMax = DTLevel[1]$IDjoueur
  
  
  sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=time)
  newres = predict(fit, newdata = sample, type = "response")
  DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMed, estDiff = newres)
  p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="blue",size=1.3,linetype="dashed")
  
  sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMin, timeNorm=time)
  newres = predict(fit, newdata = sample, type = "response")
  DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMin, estDiff = newres)
  p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
  
  sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMax, timeNorm=time)
  newres = predict(fit, newdata = sample, type = "response")
  DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMax, estDiff = newres)
  p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
  
  p <- p + theme(legend.position="none")
  
  typeXp = "(random)"
  if(randomDiff == 0)
    typeXp = "(dda)"
  lab = paste("Objective Difficulty at t=",time)
  lab = paste(lab,typeXp,' ')
  
  p <- p + xlab("Difficulty Variable") + ylab(lab) + theme(text = element_text(size=20))
  
  print(p)
}

plot.objective.diff.model.curves.time <- function (DT,fit) {
  DTLevel <- unique(DT,by="IDjoueur")
  
  DTLevelOrder = DTLevel[order(abs(niveau))]
  joueurMed = DTLevelOrder[1]$IDjoueur
  
  cols <- colorRampPalette(brewer.pal(9,"Spectral"))(11)
  
  for(i in 0:10){
    sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=i/10)#TODO plusieurs temps
    newres = predict(fit, newdata = sample, type = "response")
    DT = data.table(difficulty=seq(0, 1, 0.05),
                    IDjoueur = joueurMed, 
                    estDiff = newres,
                    timeNorm = i/10)
    if(i==0){
      p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 1,color=cols[i+1]) + xlim(0,1) + ylim(0,1)
    } else {
      p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 1,size=1,color=cols[i+1])
    }
  }
  
  p <- p + theme(legend.position="none")

  print(p)
}

plot.objective.diff.density <- function (DT) {
  p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_bin2d(binwidth=c(1,0.05))
  print(p)
}

plot.objective.diff.smooth <- function (DT,selGroup,title) {
  if(selGroup != "all")
      DT = DT[niveau.group==selGroup]
  p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_point(alpha=0.5) + geom_smooth() + xlab("Temps (tours)") + ylab("Difficulté objective") + theme(text = element_text(size=20)) + ggtitle(title)
  print(p)
}
```

##Modeling objective difficulty for motor task

```{r modeling.difficulty.motor, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY MOTOR TASK
#------------------------------------------------------
  fit.diff.motor <- model.objective.diff(DTM)
  DTM <- add.diff.obj(DTM,fit.diff.motor)
  DTM <- add.levels(DTM,fit.diff.motor)
  DTM <- add.levels.groups(DTM)
  print.objective.diff.model(DTM,fit.diff.motor)
  plot.objective.diff.model.curves(DTM,fit.diff.motor,0,T,0)
  plot.objective.diff.model.curves(DTM,fit.diff.motor,0,T,1)
  if(g.short.version == FALSE){
    plot.objective.diff.model.curves(DTM,fit.diff.motor,1)
    plot.objective.diff.model.curves.time(DTM,fit.diff.motor)
    plot.objective.diff.density(DTM)
    plot.objective.diff.smooth(DTM,"all", "motor all")
    plot.objective.diff.smooth(DTM,"bad", "motor bad")
    plot.objective.diff.smooth(DTM,"medium", "motor medium")
    plot.objective.diff.smooth(DTM,"good", "motor good")
  }
  
```

##Modeling objective difficulty for sensory task

```{r modeling.difficulty.sensory, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY SENSORY TASK
#------------------------------------------------------
  fit.diff.senso <- model.objective.diff(DTS)
  DTS <- add.diff.obj(DTS,fit.diff.senso)
  DTS <- add.levels(DTS,fit.diff.senso)
  DTS <- add.levels.groups(DTS)
  print.objective.diff.model(DTS,fit.diff.senso)
  plot.objective.diff.model.curves(DTS,fit.diff.senso,0,T,0)
  plot.objective.diff.model.curves(DTS,fit.diff.senso,0,T,1)
  if(g.short.version == FALSE){
    plot.objective.diff.model.curves(DTS,fit.diff.senso,1)
    plot.objective.diff.model.curves.time(DTS,fit.diff.senso)
    plot.objective.diff.density(DTS)
    plot.objective.diff.smooth(DTS,"all", "sensory all")
    plot.objective.diff.smooth(DTS,"bad", "sensory bad")
    plot.objective.diff.smooth(DTS,"medium", "sensory medium")
    plot.objective.diff.smooth(DTS,"good", "sensory good")
  }
```

##Modeling objective difficulty for logical task

```{r modeling.difficulty.logical, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY LOGICAL TASK
#------------------------------------------------------
  fit.diff.logic <- model.objective.diff(DTL)
  DTL <- add.diff.obj(DTL,fit.diff.logic)
  DTL <- add.levels(DTL,fit.diff.logic)
  DTL <- add.levels.groups(DTL)
  print.objective.diff.model(DTL,fit.diff.logic)
  plot.objective.diff.model.curves(DTL,fit.diff.logic,0,T,0)
  plot.objective.diff.model.curves(DTL,fit.diff.logic,0,T,1)
  if(g.short.version == FALSE){
    plot.objective.diff.model.curves(DTL,fit.diff.logic,1)
    plot.objective.diff.model.curves.time(DTL,fit.diff.logic)
    plot.objective.diff.density(DTL)
    plot.objective.diff.smooth(DTL,"all", "logical all")
    plot.objective.diff.smooth(DTL,"bad", "logical bad")
    plot.objective.diff.smooth(DTL,"medium", "logical medium")
    plot.objective.diff.smooth(DTL,"good", "logical good")
  }
```

```{r modeling.difficulty.merge, echo=FALSE}  
#------------------------------------------------------
#       MERGE INTO DTALL
#------------------------------------------------------
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
```

```{r modeling.subjective.difficulty, echo=FALSE}   
#------------------------------------------------------
#        MODELING SUBJECTIVE DIFFICULTY 
#------------------------------------------------------
DTAll$subj.diff.mise = 1 - DTAll$miseNorm;
DTAll$error.subj.diff.mise = DTAll$subj.diff.mise - DTAll$obj.diff
DTAll <- DTAll[,error.subj.diff.mise.mean:=mean(error.subj.diff.mise),by=IDjoueur]

DTAll$subj.diff.confiance = 1 - DTAll$confianceNorm;
DTAll$error.subj.diff.confiance = DTAll$subj.diff.confiance - DTAll$obj.diff
DTAll <- DTAll[,error.subj.diff.confiance.mean:=mean(error.subj.diff.confiance),by=IDjoueur]

#------------------------------------------------------
#        MAGIC CONFIDENCE ESTIMATOR
#------------------------------------------------------
#evaluating confidence as a damped over time sum of win and fails;
#each win and fail importance based on objective difficulty at that time
id = DTAll$IDjoueur # tmp vector faster to read
game = DTAll$nom_du_jeu # tmp vector faster to read
obj.diff = DTAll$obj.diff # tmp vector faster to read
gagnant = DTAll$gagnant # tmp vector faster to read

reward = 0;
cur.confidence.liss = 0;
est.confidence <- numeric(nrow(DTAll))
est.confidence[1] = 0;
alpha <- 0.8 #Vitesse de variation de la confiance
beta <- 0.6 #min modif on win or lose
maxConf <- 2 #confiance max avant normalisation (qu'elle se barre pas dans des extremes, meme si la normalisation rattrappe, elle bougera plus)
i = 1
for(i in 2:nrow(DTAll)){
  if(id[i] != id[i-1] || game[i] != game[i-1]){
    cur.confidence.liss <- 0;
  }else{
    if(gagnant[i-1]){
      reward = max(beta,obj.diff[i-1]);
    }else{
      reward = -max(beta,1 - obj.diff[i-1]);
    }
    cur.confidence.liss <-  cur.confidence.liss + alpha * reward; #évolution de la confiance
    cur.confidence.liss = sign(cur.confidence.liss) * min(maxConf,abs(cur.confidence.liss)) #on ne dépasse pas le max
  }
  est.confidence[i] <- cur.confidence.liss;
}


DTAll$est.confidence = est.confidence;

#Normalisation : max à 6, presque max à 3, 0 devient 0.5. 
DTAll$est.confidence.norm = exp(DTAll$est.confidence) / (1+exp(DTAll$est.confidence));

#update DTM DTS and DTL
DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]
```

#Influence of Player Profiles

##Player profiles

```{r show.player.profiles, echo=FALSE} 
#------------------------------------------------------
#        SHOWING PLAYERS' PROFILES
#------------------------------------------------------

if(g.short.version == FALSE && g.withplayerprofiles.version == TRUE){

  #OLD REPRESENTATION
  # hist(unique(DTM,by="IDjoueur")$age,breaks=30,main="Age of players")
  # hist(unique(DTM,by="IDjoueur")$sexe,main="Sex of players")
  # hist(unique(DTM,by="IDjoueur")$play.video.games,main="Playing Video Games")
  # hist(unique(DTM,by="IDjoueur")$play.board.games,main="Playing Board Games")
  # hist(unique(DTM,by="IDjoueur")$self.eff,main="Self efficacy")
  # hist(unique(DTM,by="IDjoueur")$risk.av,main="Risk aversion")
  
  #âge des participants
  counts <- table(unique(DTAll,by="IDjoueur")$age)
  bpAge <- barplot(counts, 
                col = c("lightblue", "lightgreen"),
                xlab="Age",  
                ylab="Distribution by participants", 
                ylim = c(0, 15))
  text(bpAge, 0, round(counts, 1),cex=0.5,pos=3)
  
  #niveau d'étude
  precounts <- unique(DTAll,by="IDjoueur")$niveauEtude
  counts <- table(factor(precounts,levels=1:9))
  bpEtudes <- barplot(counts, main="Certificate levels", horiz=FALSE,
                      names.arg=c("None", "BEPC", "BEP/CAP", "BAC", "BAC+2", "BAC+3", "BAC+4", "BAC+5", "BAC+8"),
                      legend.text = NULL, beside = TRUE,
                      axes = TRUE, axisnames = TRUE,
                      xlab="Certificate levels",  
                      ylab="Distribution by participants",
                      xlim = c(0, 10),
                      ylim = c(0, 35),
                      cex.names=0.8)
  text(bpEtudes, 0, round(counts, 1),cex=0.5,pos=3)
  
  #sexe des joueurs
  counts <- table(unique(DTAll,by="IDjoueur")$sexe)
  bpSexe <- barplot(counts, main="Genre of players", horiz=FALSE,
                      names.arg=c("Male", "Female"),
                      legend.text = NULL, beside = TRUE,
                      axes = TRUE, axisnames = TRUE,
                      col = c("lightblue", "lightgreen"),  
                      xlab="Genre of players",  
                      ylab="Distribution by participants",
                      xlim = c(0, 3),
                      ylim = c(0, 60),
                      cex.names=1)
  text(bpSexe, 0, round(counts, 1),cex=0.8,pos=3)
  
  #joueurs de jeux vidéo
  counts <- table(unique(DTAll,by="IDjoueur")$play.video.games)
  bpVideoGames <- barplot(counts, main="Playing Video Games", horiz=FALSE,
                      names.arg=c("Never", "Almost never", "Monthly", "Weekly", "Daily"),
                      legend.text = NULL, beside = TRUE,
                      axes = TRUE, axisnames = TRUE,
                      #col = c("lightblue", "lightgreen"),  
                      xlab="Playing Video Games",  
                      ylab="Distribution by participants",
                      xlim = c(0, 6),
                      ylim = c(0, 50),
                      cex.names=1)
  text(bpVideoGames, 0, round(counts, 1),cex=0.8,pos=3)
  
  #joueurs de jeux de société
  counts <- table(unique(DTAll,by="IDjoueur")$play.board.games)
  bpBoardGames <- barplot(counts, main="Playing Board Games", horiz=FALSE,
                      names.arg=c("Never", "Almost never", "Monthly", "Weekly", "Daily"),
                      legend.text = NULL, beside = TRUE,
                      axes = TRUE, axisnames = TRUE,
                      #col = c("lightblue", "lightgreen"),  
                      xlab="Playing Board Games",  
                      ylab="Distribution by participants",
                      xlim = c(0, 6),
                      ylim = c(0, 35),
                      cex.names=1)
  text(bpBoardGames, 0, round(counts, 1),cex=0.8,pos=3)
  
  #sentiment d'auto-efficacité
  #counts <- table(unique(DTM,by="IDjoueur")$self.eff)
  counts <- table(exclude = NA, unique(DTAll,by="IDjoueur")$self.eff) #ne garder que les joueurs de jeux vidéo (donc                                                                        self.eff > 0)
  bpSelfEff <- barplot(counts, main="Self-efficacy in video games", horiz=FALSE,
                      legend.text = NULL, beside = TRUE,
                      axes = TRUE, axisnames = TRUE,
                      #col = c("lightblue", "lightgreen"),  
                      xlab="Self-efficacy in video games",  
                      ylab="Distribution by video games players",
                      #xlim = c(0, 30),
                      ylim = c(0, 8),
                      cex.names=0.8)
  text(bpSelfEff, 0, round(counts, 1),cex=0.8,pos=3)
  legend("topright", legend = "From 0.5 as Medium to 1 as Strong")
  
  #aversion au risque
  counts <- table(unique(DTAll,by="IDjoueur")$risk.av)
  bpRiskAver <- barplot(counts, main="Risk aversion", horiz=FALSE,
                      #names.arg=c("Very highly risk loving", "Highly risk loving", "Risk loving", "Risk neutral", "Slightly risk averse", "Risk averse", "Very risk averse", "Highly risk averse", "stay in bed"),
                      legend.text = NULL, beside = TRUE,
                      axes = TRUE, axisnames = TRUE,
                      #col = c("lightblue", "lightgreen"),  
                      xlab="Risk aversion",  
                      ylab="Distribution by participants",
                      xlim = c(0, 10),
                      ylim = c(0, 20),
                      cex.names=0.9)
  text(bpRiskAver, 0, round(counts, 1),cex=0.8,pos=3)
}

```

##Influence of Player Profiles

```{r player.model.subjective.difficulty, echo=FALSE}
#------------------------------------------------------
#        INFLUENCE OF PLAYERS' PROFILES 
#------------------------------------------------------

#si X est continu
test.profile <- function(Y,X,title){
  test <- cor.test(Y,X, method="kendall")
  DT <- data.table(x=X,y=Y)
  p <- ggplot(DT,aes(x, y)) + geom_point(alpha=0.5)
  print(p)
  res <- paste(signif(test$estimate,digits=2),format.pval.stars(test$p.value))
  print(test)
  if(test$p.value < 0.1){
    print(paste(title,res))
  }
  return(res)
}

test.profile.binary <- function(A,B,title){
  DTA <- data.table(gp="A",val=A)
  DTB <- data.table(gp="B",val=B)
  DT <- rbind(DTA,DTB)
  p <- ggplot(DT,aes(gp, val)) + geom_point(alpha=0.5)
  print(p)
  test <- wilcox.test(B,A,conf.int=T)
  print(test)
  res <- paste(signif(test$estimate,digits=2),format.pval.stars(test$p.value))
  if(test$p.value < 0.1){
    res <- paste(res,paste("mean(A):",signif(mean(A),digit=2)))
    res <- paste(res,paste("mean(B):",signif(mean(B),digit=2)))
    print(paste(title,res))
  }
    
  return(res)
}

#si X est un label, comparaison entre groupes
test.profile.multigroups <- function(Y,X,title){
  test <- kruskal.test(Y ~ X) 
  res <- paste(format.pval.stars(test$p.value))
  if(test$p.value < 0.1){
    print(paste(title,res))
  }
    
  return(res)
}


```

##Objective level and player profile

### Playing video games in general and level for each task

```{r echo=FALSE}
#---------------------------------------------------------------------
#        INFLUENCE OF VIDEO GAME EXPERTISE ON PLAYERS' PERFORMANCE
#---------------------------------------------------------------------
if(g.short.version == FALSE){
  pvg.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$play.video.games,"pvg.on.level.m")
  pvg.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$play.video.games,"pvg.on.level.s")
  pvg.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$play.video.games,"pvg.on.level.l")
}
```

### Playing board games in general and level for each task

```{r echo=FALSE}
#----------------------------------------------------------------------
#        INFLUENCE OF BOARD GAME EXPERTISE ON PLAYERS' PERFORMANCE
#----------------------------------------------------------------------
if(g.short.version == FALSE){
  pbg.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$play.board.games,"pbg.on.level.m")
  pbg.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$play.board.games,"pbg.on.level.s")
  pbg.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$play.board.games,"pbg.on.level.l")
}
```

### Self efficacy and level for each task

```{r echo=FALSE}
#----------------------------------------------------------------------
#        INFLUENCE OF SELF-EFFICACY ON PLAYERS' PERFORMANCE
#----------------------------------------------------------------------
if(g.short.version == FALSE){
  self.eff.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$self.eff,"self.eff.on.level.m")
  self.eff.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$self.eff,"self.eff.on.level.s")
  self.eff.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$self.eff,"self.eff.on.level.l")
}
```

### Risk aversion and level for each task

```{r echo=FALSE}
#----------------------------------------------------------------------
#        INFLUENCE OF RISK AVERSION ON PLAYERS' PERFORMANCE
#----------------------------------------------------------------------
if(g.short.version == FALSE){
  risk.av.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$risk.av,"risk.av.on.level.m")
  risk.av.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$risk.av,"risk.av.on.level.s")
  risk.av.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$risk.av,"risk.av.on.level.l")
}
```

### Age and level for each task

```{r echo=FALSE}
#----------------------------------------------------------------------
#        INFLUENCE OF AGE AND LEVEL ON PLAYERS' PERFORMANCE
#----------------------------------------------------------------------
if(g.short.version == FALSE){
  age.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$age,"age.on.level.m")
  age.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$age,"age.on.level.s")
  age.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$age,"age.on.level.l")
}
```

### Sex and level for each task

```{r echo=FALSE}
#----------------------------------------------------------------------
#        INFLUENCE OF SEX AND LEVEL ON PLAYERS' PERFORMANCE
#----------------------------------------------------------------------
if(g.short.version == FALSE){
  sexe.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$sexe,"sexe.on.level.m")
  sexe.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$sexe,"sexe.on.level.s")
  sexe.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$sexe,"sexe.on.level.l")
  
  sexe.on.level.m.2 <- test.profile.binary(unique(DTM[sexe==0],by="IDjoueur")$niveau, unique(DTM[sexe==1],by="IDjoueur")$niveau,"sexe.on.level.m.2")
  sexe.on.level.s.2 <- test.profile.binary(unique(DTS[sexe==0],by="IDjoueur")$niveau, unique(DTS[sexe==1],by="IDjoueur")$niveau,"sexe.on.level.s.2")
  sexe.on.level.l.2 <- test.profile.binary(unique(DTL[sexe==0],by="IDjoueur")$niveau, unique(DTL[sexe==1],by="IDjoueur")$niveau,"sexe.on.level.l.2")
}
```


#Influence of Objective difficulty on Subjective Difficulty

```{r plot.subjective.objective.difficulty, echo=FALSE}   
#-------------------------------------------------------------------------------------
#     SHOWING SUBJECTIVE VS OBJECTIVE DIFFICULTY
#-------------------------------------------------------------------------------------

plot.subjective.difficulty <- function(DT,selGroup,title,useConfiance){
  
  # Lien entre confiance normalisée et difficultée estimée (hard / easy effect)
  obj.diff.quants = seq(0,1,1/16) #quantile(DT$obj.diff, probs=(seq(0,1,0.05)))
  nb.bins = length(obj.diff.quants)-1
  subj.diff.med.rnd = numeric(nb.bins)
  subj.diff.med.dda = numeric(nb.bins)
  obj.diff.bin = numeric(nb.bins)
  obj.diff.bin.cur = 0;
  test.pvals = numeric(nb.bins)
  conf.min = numeric(nb.bins)
  conf.max = numeric(nb.bins)
  nb.vals.rnd = numeric(nb.bins)
  nb.vals.dda = numeric(nb.bins)
  shapes.rnd =  numeric(nb.bins)
  shapes.dda =  numeric(nb.bins)
  delta.obj.subj = numeric(nb.bins)
  subj.diff.delta.rnd.dda = numeric(nb.bins)
  
  for(i in 1:nb.bins){
    #obj.diff.bin.cur = round(i/10,1)
    #subj.diff = DT[round(obj.diff,1)==obj.diff.bin.cur]$subj.diff.mise
    obj.diff.bin.cur = (obj.diff.quants[i] + obj.diff.quants[i+1])/2.0
    #subj.diff = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]$subj.diff.mise
    DTLoc = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]
    
    if(selGroup != "all")
      DTLoc = DDTLoc=DTLoc[niveau.group==selGroup]
    
    if(useConfiance)
      DTLoc = DTLoc[,.(random_diff,subj.diff.mean=mean(subj.diff.confiance)),by=IDjoueur]
    else
      DTLoc = DTLoc[,.(random_diff,subj.diff.mean=mean(subj.diff.mise)),by=IDjoueur]
    
    

    subj.diff.rnd = DTLoc[random_diff==1]$subj.diff.mean
    subj.diff.dda = DTLoc[random_diff==0]$subj.diff.mean
    
    obj.diff.bin[i] = obj.diff.bin.cur
    
    subj.diff.med.dda[i] = NA
    subj.diff.med.rnd[i] = NA
    
    test.pvals[i] = NA
    conf.min[i] = NA
    conf.max[i] = NA
    
    shapes.rnd[i] = 1
    shapes.dda[i] = 2
    nb.vals.rnd[i] = length(subj.diff.rnd)
    nb.vals.dda[i] = length(subj.diff.dda)
    
    if(nb.vals.rnd[i] > 10)
      subj.diff.med.rnd[i] = mean(subj.diff.rnd)
    if(nb.vals.dda[i] > 10)
      subj.diff.med.dda[i] = mean(subj.diff.dda)
    
    if(nb.vals.rnd[i] > 10 && nb.vals.dda[i] > 10){
      try.res = try(test.res <- wilcox.test(x=subj.diff.rnd,y=subj.diff.dda,conf.int=T,paired=FALSE))
      if (class(try.res) != "try-error"){
        #print(test.res)
        #hist(subj.diff)
        test.pvals[i] = format.pval.stars(test.res$p.value)
        
        if(test.res$p.value < 0.05){
          shapes.rnd[i] = 16
          shapes.dda[i] = 17
        }
        
        subj.diff.delta.rnd.dda[i] = test.res$estimate
        conf.min[i] = test.res$conf.int[1]
        conf.max[i] = test.res$conf.int[2]
      }
    }
  }

  i=1#print table of pvalues
  print(data.table(obj.diff.bin=obj.diff.bin,subj.diff.delta.rnd.dda=subj.diff.delta.rnd.dda,n.rnd=nb.vals.rnd,n.dda=nb.vals.dda,pval=test.pvals))

  DTPlotRnd = data.table(obj.diff=obj.diff.bin,subj.diff=subj.diff.med.rnd, shapes=shapes.rnd)
  DTPlotDda = data.table(obj.diff=obj.diff.bin,subj.diff=subj.diff.med.dda, shapes=shapes.dda)

  p = ggplot() + ggtitle(title) +
        geom_point(aes(x=DTPlotRnd$obj.diff,y=DTPlotRnd$subj.diff),alpha = 1, size = 3, shape=DTPlotRnd$shapes) +
        geom_point(aes(x=DTPlotDda$obj.diff,y=DTPlotDda$subj.diff),alpha = 1, size = 3, shape=DTPlotDda$shapes) +
        xlim(0,1)+
        ylim(0,1)+
        #geom_errorbar(aes(x=DTPlotRnd$obj.diff, ymin=conf.min, ymax=conf.max), width=.01,color="red")  +
        geom_abline(intercept = 0, slope = 1, color="blue") +
        xlab("Difficulté objective") + ylab("Difficulté subjective") + theme(text = element_text(size=15))

  print(p)
  
  # print(selGroup)
  # 
  # # Lien entre confiance normalisée et difficultée estimée (hard / easy effect)
  # obj.diff.quants = seq(0,1,1/16)#quantile(DT$obj.diff, probs=(seq(0,1,0.05)))
  # nb.bins = length(obj.diff.quants)-1
  # subj.diff.med = numeric(nb.bins)
  # obj.diff.bin = numeric(nb.bins)
  # obj.diff.bin.cur = 0;
  # test.pvals = numeric(nb.bins)
  # conf.min = numeric(nb.bins)
  # conf.max = numeric(nb.bins)
  # nb.vals = numeric(nb.bins)
  # shapes =  numeric(nb.bins)
  # delta.obj.subj = numeric(nb.bins)
  # hist(DT$obj.diff)
  # 
  # for(i in 1:nb.bins){
  #   #obj.diff.bin.cur = round(i/10,1)
  #   #subj.diff = DT[round(obj.diff,1)==obj.diff.bin.cur]$subj.diff.mise
  #   obj.diff.bin.cur = (obj.diff.quants[i] + obj.diff.quants[i+1])/2.0
  #   #subj.diff = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]$subj.diff.mise
  #   DTLoc = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]
  #   if(selGroup != "all")
  #     DTLoc = DTLoc[niveau.group==selGroup]
  #   if(useConfiance)
  #     DTLoc = DTLoc[,.(subj.diff.mean=mean(subj.diff.confiance)),by=IDjoueur]
  #   else
  #     DTLoc = DTLoc[,.(subj.diff.mean=mean(subj.diff.mise)),by=IDjoueur]
  #   
  #   subj.diff = DTLoc$subj.diff.mean
  #   obj.diff.bin[i] = obj.diff.bin.cur
  #   subj.diff.med[i] = NA
  #   test.pvals[i] = NA
  #   conf.min[i] = NA
  #   conf.max[i] = NA
  #   delta.obj.subj[i] = NA
  #   shapes[i] = 16
  #   nb.vals[i] = length(subj.diff)
  #   if(nb.vals[i] > 1){
  #     try.res = try(test.res <- wilcox.test(subj.diff,mu = obj.diff.bin.cur,conf.int=T))
  #     if (class(try.res) != "try-error"){
  #       #print(test.res)
  #       #hist(subj.diff)
  #       test.pvals[i] = format.pval.stars(test.res$p.value)
  #       if(test.res$p.value < 0.05)
  #         shapes[i] = 24
  #       #subj.diff.med[i] = mean(subj.diff)
  #       subj.diff.med[i] = test.res$estimate
  #       conf.min[i] = test.res$conf.int[1]
  #       conf.max[i] = test.res$conf.int[2]
  #       delta.obj.subj[i] = signif(subj.diff.med[i] - obj.diff.bin.cur,digit=2)
  #     }
  #   }
  # }
  # 
  # #print table of pvalues
  # print(data.table(obj.diff.bin=obj.diff.bin,delta.obj.subj=delta.obj.subj,n=nb.vals,pval=test.pvals))
  # 
  # #summary
  # print("mean and sd of nb players per bin")
  # DTNbVals = data.table(nb = nb.vals, pval=test.pvals)
  # print(DTNbVals[!is.na(pval)])
  # print(signif(mean(DTNbVals[!is.na(pval)]$nb),digits=3))
  # print(signif(sd(DTNbVals[!is.na(pval)]$nb),digits=3))
  # 
  # DTPlot = data.table(obj.diff=obj.diff.bin,subj.diff=subj.diff.med, shapes=shapes)
  # 
  # p = ggplot() + ggtitle(title) +
  #       geom_point(aes(x=DTPlot$obj.diff,y=DTPlot$subj.diff),alpha = 1, size = 3, shape=DTPlot$shapes) +
  #       xlim(0,1)+
  #       ylim(0,1)+
  #       geom_errorbar(aes(x=DTPlot$obj.diff, ymin=conf.min, ymax=conf.max), width=.01,color="red")  +
  #       geom_abline(intercept = 0, slope = 1, color="blue") +
  #       xlab("Difficulté objective") + ylab("Difficulté subjective") + theme(text = element_text(size=15))
  # 
  # print(p)
  
  
}
```

##All tasks

```{r plot.subjective.difficulty.all.confidence.scale, echo=FALSE}
plot.subjective.difficulty(DTAll,"all", "All tasks, all groups",g.use.confiance)
if(g.short.version == FALSE){
  plot.subjective.difficulty(DTAll,"good", "All tasks, good",g.use.confiance)
  plot.subjective.difficulty(DTAll,"medium", "All tasks, medium",g.use.confiance)
  plot.subjective.difficulty(DTAll,"bad", "All tasks, bad",g.use.confiance)
}
```

##Motor task

```{r plot.subjective.difficulty.motor.confidence.scale, echo=FALSE}
plot.subjective.difficulty(DTM,"all", "Motor, all",g.use.confiance)
if(g.short.version == FALSE){
  plot.subjective.difficulty(DTM,"good", "Motor, good",g.use.confiance)
  plot.subjective.difficulty(DTM,"medium", "Motor, medium",g.use.confiance)
  plot.subjective.difficulty(DTM,"bad", "Motor, bad",g.use.confiance)
}
```

##Sensory task

```{r plot.subjective.difficulty.sensory.confidence.scale, echo=FALSE}
plot.subjective.difficulty(DTS,"all","Sensory, all",g.use.confiance)
if(g.short.version == FALSE){
  plot.subjective.difficulty(DTS,"good","Sensory, good",g.use.confiance)
  plot.subjective.difficulty(DTS,"medium","Sensory, medium",g.use.confiance)
  plot.subjective.difficulty(DTS,"bad","Sensory, bad",g.use.confiance)
}
```

##Logical task

```{r plot.subjective.difficulty.logical.confidence.scale, echo=FALSE}
plot.subjective.difficulty(DTL,"all","Logical, all",g.use.confiance)
if(g.short.version == FALSE){
  plot.subjective.difficulty(DTL,"good","Logical, good",g.use.confiance)
  plot.subjective.difficulty(DTL,"medium","Logical, medium",g.use.confiance)
  plot.subjective.difficulty(DTL,"bad","Logical, bad",g.use.confiance)
}
```

#Influence of Playtime on Subjective Difficulty Error

```{r platytime.subjective.difficulty.funcs.confidence.scale, echo=FALSE} 
plot.subjective.diff.error.density <- function (DT) {
  p <- ggplot(DT, aes(action_de_jeu, error.subj.diff.confiance)) + geom_bin2d(binwidth=c(1,0.05))
  print(p)
}

plot.subj.obj.diff.with.time <- function(DT,selGroup,diffObjGroup,title){
  
  dstart = 0;
  dend = 1;
  if(diffObjGroup != "all"){
    if(diffObjGroup == "easy"){
      dstart = 0;
      dend = 1/3;
    }
    if(diffObjGroup == "medium"){
      dstart = 1/3;
      dend = 2/3;
    }
    if(diffObjGroup == "hard"){
      dstart = 2/3;
      dend = 1;
    }
    
  }
  
  time.quants = seq(0,30,3)#quantile(DT$obj.diff, probs=(seq(0,1,0.05)))
  nb.bins = length(time.quants)-1
  time.bin = numeric(nb.bins)
  nb.vals = numeric(nb.bins)
  error.diff = numeric(nb.bins)
  # 
  # obj.diff.bin.cur = 0;
  test.pvals = numeric(nb.bins)
  conf.min = numeric(nb.bins)
  conf.max = numeric(nb.bins)
  subj.diff.mean = numeric(nb.bins)
  obj.diff.mean = numeric(nb.bins)
  shapes =  numeric(nb.bins)
  # delta.obj.subj = numeric(nb.bins)
  # hist(DT$obj.diff)
  for(i in 1:nb.bins){
    time.bin.cur = (time.quants[i] + time.quants[i+1])/2.0
    DTLoc = DT[action_de_jeu > time.quants[i] & action_de_jeu<=time.quants[i+1] & obj.diff > dstart & obj.diff <= dend]
    if(selGroup != "all")
      DTLoc = DTLoc[niveau.group==selGroup]
    time.bin[i] = time.bin.cur
    subj.diff = DTLoc$subj.diff.confiance
    obj.diff = DTLoc$obj.diff
    # subj.diff.med[i] = NA
    test.pvals[i] = NA
    conf.min[i] = NA
    conf.max[i] = NA
    error.diff[i] = NA
    subj.diff.mean[i] = NA
        obj.diff.mean[i] = NA
    # delta.obj.subj[i] = NA
    shapes[i] = 16
    nb.vals[i] = length(subj.diff)
    if(nb.vals[i] > 1){
      try.res = try(test.res <- wilcox.test(subj.diff,obj.diff,conf.int=T, paired=T)) 
      if (class(try.res) != "try-error"){
        #print(test.res)
        #hist(subj.diff)
        test.pvals[i] = format.pval.stars(test.res$p.value)
        if(test.res$p.value < 0.05)
          shapes[i] = 24
        subj.diff.mean[i] = mean(subj.diff)
        obj.diff.mean[i] = mean(obj.diff)
        error.diff[i] = test.res$estimate
        conf.min[i] = test.res$conf.int[1]
        conf.max[i] = test.res$conf.int[2]
        #delta.obj.subj[i] = signif(subj.diff.med[i] - obj.diff.bin.cur,digit=2)
      }
    }
  }
  
  #print table of pvalues
  print(data.table(time.bin=time.bin,subj.diff.mean=subj.diff.mean,obj.diff.mean=obj.diff.mean,error.diff=error.diff,n=nb.vals,pval=test.pvals))
 
  #kernel smooth
  # subj.diff.smooth <- ksmooth(x=DT$obj.diff,y=DT$subj.diff.mise,bandwidth = 0.2)
  # DTSmooth = data.table(x=subj.diff.smooth$x,y=subj.diff.smooth$y)
   
   DTPlot = data.table(time=time.bin,error.diff=error.diff, shapes=shapes)
   print(DTPlot)
  # 
  p = ggplot() + ggtitle(title) +

        geom_point(aes(x=DTPlot$time,y=DTPlot$error.diff),alpha = 1, size = 3, shape=DTPlot$shapes) +
        xlim(0,30)+
        ylim(-0.4,0.2)+
        geom_errorbar(aes(x=DTPlot$time, ymin=conf.min, ymax=conf.max), width=.01,color="red")  +
        geom_abline(intercept = 0, slope = 0, color="blue") +
        xlab("Temps") + ylab("Erreur d'estimation de la difficulté") + theme(text = element_text(size=15))

  print(p)
}



``` 

##For all groups, motor, sensitive and logical

```{r platytime.subjective.difficulty.all.confidence.scale, echo=FALSE} 
if(g.short.version == FALSE){
  plot.subjective.diff.error.density(DTM)
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTM))
  plot.subjective.diff.error.density(DTS)
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTS))
  plot.subjective.diff.error.density(DTL)
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTL))
}

plot.subj.obj.diff.with.time(DTM,"all", "all", "Motor, all groups, all diffs")
plot.subj.obj.diff.with.time(DTM,"all", "easy", "Motor, all groups, easy diff")
plot.subj.obj.diff.with.time(DTM,"all", "medium", "Motor, all groups, medium diff")
plot.subj.obj.diff.with.time(DTM,"all", "hard", "Motor, all groups, hard diff")
plot.subj.obj.diff.with.time(DTS,"all", "all","Sensory, all groups")
plot.subj.obj.diff.with.time(DTS,"all", "easy", "Sensory, all groups, easy diff")
plot.subj.obj.diff.with.time(DTS,"all", "medium", "Sensory, all groups, medium diff")
plot.subj.obj.diff.with.time(DTS,"all", "hard", "Sensory, all groups, hard diff")
plot.subj.obj.diff.with.time(DTL,"all", "all","Logical, all groups")
plot.subj.obj.diff.with.time(DTL,"all", "easy", "Logical, all groups, easy diff")
plot.subj.obj.diff.with.time(DTL,"all", "medium", "Logical, all groups, medium diff")
plot.subj.obj.diff.with.time(DTL,"all", "hard", "Logical, all groups, hard diff")

``` 

##For all taks, per group

```{r platytime.subjective.difficulty.all.tasks.confidence.scale, echo=FALSE} 
if(g.short.version == FALSE){
  plot.subjective.diff.error.density(DTAll[niveau.group=="bad"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTAll[niveau.group=="bad"]))
  plot.subjective.diff.error.density(DTAll[niveau.group=="medium"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTAll[niveau.group=="medium"]))
  plot.subjective.diff.error.density(DTAll[niveau.group=="good"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTAll[niveau.group=="good"]))
  
  plot.subj.obj.diff.with.time(DTAll,"bad", "bad", "All tasks, bad")
  plot.subj.obj.diff.with.time(DTAll,"medium", "medium", "All tasks, medium")
  plot.subj.obj.diff.with.time(DTAll,"good", "good", "All tasks, good")
}
``` 


##Per group, motor task

```{r platytime.subjective.difficulty.group.motor.confidence.scale, echo=FALSE} 
if(g.short.version == FALSE){
  plot.subjective.diff.error.density(DTM[niveau.group=="bad"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTM[niveau.group=="bad"]))
  plot.subj.obj.diff.with.time(DTM,"bad", "bad", "Motor, bad")
  plot.subjective.diff.error.density(DTM[niveau.group=="medium"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTM[niveau.group=="medium"]))
  plot.subj.obj.diff.with.time(DTM,"medium", "medium", "Motor, medium")
  plot.subjective.diff.error.density(DTM[niveau.group=="good"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTM[niveau.group=="good"]))
  plot.subj.obj.diff.with.time(DTM,"good", "good", "Motor, good")
}

``` 

##Per group, sensory task

```{r platytime.subjective.difficulty.group.sensory.confidence.scale, echo=FALSE} 
if(g.short.version == FALSE){
  plot.subjective.diff.error.density(DTS[niveau.group=="bad"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTS[niveau.group=="bad"]))
  plot.subj.obj.diff.with.time(DTS,"bad", "bad", "Sensory, bad")
  plot.subjective.diff.error.density(DTS[niveau.group=="medium"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTS[niveau.group=="medium"]))
  plot.subj.obj.diff.with.time(DTS,"medium", "medium", "Sensory, medium")
  plot.subjective.diff.error.density(DTS[niveau.group=="good"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTS[niveau.group=="good"]))
  plot.subj.obj.diff.with.time(DTS,"good", "good", "Sensory, good")
}
``` 

##Per group, logical task

```{r platytime.subjective.difficulty.group.logical.confidence.scale, echo=FALSE} 
if(g.short.version == FALSE){
  plot.subjective.diff.error.density(DTL[niveau.group=="bad"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTL[niveau.group=="bad"]))
  plot.subj.obj.diff.with.time(DTL,"bad", "bad", "Logical, bad")
  plot.subjective.diff.error.density(DTL[niveau.group=="medium"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTL[niveau.group=="medium"]))
  plot.subj.obj.diff.with.time(DTL,"medium", "medium", "Logical, medium")
  plot.subjective.diff.error.density(DTL[niveau.group=="good"])
  summary(glm(error.subj.diff.confiance~timeNorm + obj.diff,data = DTL[niveau.group=="good"]))
  plot.subj.obj.diff.with.time(DTL,"good", "good", "Logical, good")
}
```
