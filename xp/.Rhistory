print(paste("Total number of outliers: ",toString(nrow(unique(outliers,by="id")))))
print(paste("Total number of outliers motor task: ",toString(nrow(unique(outliers[type=="Moteur"],by="id")))))
print(paste("Total number of outliers perceptive task: ",toString(nrow(unique(outliers[type=="Logique"],by="id")))))
print(paste("Total number of outliers logical task: ",toString(nrow(unique(outliers[type=="Sensoriel"],by="id")))))
```
```{r remove.outliers, echo=FALSE}
#------------------------------------------------------
#            REMOVING OUTLIERS FROM TABLES
#------------------------------------------------------
# removing all outliers
DTM <- DTM[!IDjoueur %in% unlist(outliers[type=="Moteur"]$id)]
DTS <- DTS[!IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id)]
DTL <- DTL[!IDjoueur %in% unlist(outliers[type=="Logique"]$id)]
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
```
```{r modeling.difficulty.compute.utils, echo=FALSE}
#------------------------------------------------------
#            MODELING OBJECTIVE DIFFICULTY
#------------------------------------------------------
#modeling difficulty as mixed effect linear model
model.objective.diff <- function(DT){
return(glmer(perdant ~ difficulty + timeNorm + (1 | IDjoueur), data=DT,family = "binomial"(link = "logit")))
}
add.diff.obj <- function (DT,fit){
sample = data.frame(difficulty=DT$difficulty, IDjoueur=DT$IDjoueur, timeNorm=DT$timeNorm)
DT$obj.diff =  predict(fit, newdata = sample, type = "response")
return (DT)
}
#cross val difficulty model
get.model.accuracy <- function(DT){
DT$cross.val.group = round(runif(nrow(DT),0.5,10.5))
totAccuracy <- 0
for(i in 1:10){
DTModel <-  DT[cross.val.group != i]
DTTest <- DT[cross.val.group == i]
fit <- model.objective.diff(DTModel)
newres = predict(fit, newdata = DTTest, type = "response")
newres = round(newres)
accuracy = abs(newres - DTTest$perdant)
localAccu = table(accuracy)[[1]]/length(accuracy)
totAccuracy <-  totAccuracy + localAccu
#print(localAccu)
}
totAccuracy = totAccuracy / 10
return (totAccuracy)
}
model.objective.diff.basic<- function(DT){
#on divise par bins
gameplay.diff.quants = quantile(DT$difficulty,probs = seq(0, 1, 0.025)) #seq(0,1,0.025)
print(gameplay.diff.quants)
nb.bins = length(gameplay.diff.quants)-1
for(i in 1:nb.bins){
if(i == 1)
DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
else
DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
}
DTLoc = DT[,.(nb=nrow(.SD), diff.subj.sigma = sd(1-miseNorm),diff.subj = mean(1-miseNorm), obj.diff.basic=mean(perdant), gameplay=mean(difficulty)) ,by=bin.gameplay]
p = ggplot(DTLoc,aes(x=gameplay,y=obj.diff.basic)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1) + geom_point(x=DTLoc$gameplay, y=DTLoc$diff.subj, alpha = 1, size=3, color="red")
print(p)
p = ggplot(DTLoc,aes(x=obj.diff.basic,y=diff.subj)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1)
print(p)
return (DTLoc)
}
add.diff.obj.basic <- function (DT){
#on divise par bins
gameplay.diff.quants = seq(0,1,0.1)
nb.bins = length(gameplay.diff.quants)-1
for(i in 1:nb.bins){
if(i == 1)
DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
else
DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
}
DT[,obj.diff.basic:=mean(difficulty),by=bin.gameplay]
return (DT)
}
get.levels <- function(DT,fit){
fit.ranef = ranef(fit)$IDjoueur
DTLevel <- data.table(IDjoueur=rownames(fit.ranef),niveau=-fit.ranef); # ! minus, cause it's a level
setnames(DTLevel,"niveau.(Intercept)","niveau")
return(DTLevel)
}
add.levels <- function(DT,fit){
DTLevel <- get.levels(DT,fit)
return(merge(DT,DTLevel,by="IDjoueur",all=T))
}
#TODO par groupe
add.levels.groups<- function(DT){
#fit = hclust(dist(DT$niveau), "ward.D2")
#plot(fit,hang=-1)
#groups <- cutree(fit, k=3)
nbJoueur <- nrow(unique(DT,by="niveau"))
fit<-kmeans(DT$niveau,min(nbJoueur,3))
groups<-fit$cluster
DT$niveau.group = factor(groups)
levels.order = DT[order(niveau),.(ordered.group=niveau.group),by=niveau.group]
levels.factors = levels(factor(c("bad","medium","good"),levels=c("bad","medium","good"),ordered=T))
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[1]$niveau.group] <- levels.factors[1]
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[2]$niveau.group] <- levels.factors[2]
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[3]$niveau.group] <- levels.factors[3]
return(DT)
}
```
```{r modeling.difficulty.draw.utils, echo=FALSE}
#------------------------------------------------------
#         SHOWING OBJECTIVE DIFFICULTY
#------------------------------------------------------
print.objective.diff.model <- function (DT,fit) {
print(summary(fit))
fit.ranef = ranef(fit)$IDjoueur
fit.sum = unlist(summary(fit))
inter = fit.sum$coefficients1
beta.diff = fit.sum$coefficients2
beta.time = fit.sum$coefficients3
inter.p.val = fit.sum$coefficients10
beta.diff.p.val = fit.sum$coefficients11
beta.time.p.val = fit.sum$coefficients12
fit.r.value.fix = r.squaredGLMM(fit)[1] #R2 for fixed effect model
fit.r.value.mix = r.squaredGLMM(fit)[2] #R2 for mixed effect model
fit.cross.val = get.model.accuracy(DT)
fit.aic = AIC(fit)
print(table(DT$nom_du_jeu))
print("Player levels from ranef:")
print(summary(fit.ranef))
print(paste("Intercept:",format.coef(inter,inter.p.val)))
print(paste("Difficulty:",format.coef(beta.diff,beta.diff.p.val)))
print(paste("Time:",format.coef(beta.time,beta.time.p.val)))
print(paste("R2 fixed:",signif(fit.r.value.fix,digits=2)))
print(paste("R2 mixed:",signif(fit.r.value.mix,digits=2)))
print(paste("Cross Val:",signif(fit.cross.val,digits=2)))
print(paste("AIC:",signif(fit.aic,digits=2)))
}
plot.objective.diff.model.curves <- function (DT,fit,time=1,groups=T) {
#DTLevel <- get.levels(DT,fit)
DTLevel <- unique(DT,by="IDjoueur")
if(groups){
DTLevel[niveau.group=="bad",group.color:=as.character("yellow")]
DTLevel[niveau.group=="medium",group.color:=as.character("cyan")]
DTLevel[niveau.group=="good",group.color:=as.character("green")]
}else{
DTLevel[niveau.group=="bad",group.color:=as.character("black")]
DTLevel[niveau.group=="medium",group.color:=as.character("black")]
DTLevel[niveau.group=="good",group.color:=as.character("black")]
}
for(i in 1:nrow(DTLevel)){
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=DTLevel[i]$IDjoueur, timeNorm=time)#TODO plusieurs temps
newres = predict(fit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),
IDjoueur = DTLevel[i]$IDjoueur,
estDiff = newres,
group.color = DTLevel[i]$group.color)
if(i==1){
p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 0.2,colour=DT$group.color) + xlim(0,1) + ylim(0,1)
} else {
p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 0.2,size=1,colour=DT$group.color)
}
}
DTLevel = DTLevel[order(abs(niveau))];
joueurMed = DTLevel[1]$IDjoueur
level.quants = quantile(DTLevel$niveau,probs = seq(0, 1, 0.25))
print(level.quants)
DTLevel = DTLevel[order(abs(niveau - (level.quants[2])))];
joueurMin = DTLevel[1]$IDjoueur
DTLevel = DTLevel[order(abs(niveau - (level.quants[4])))];
joueurMax = DTLevel[1]$IDjoueur
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMed, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="blue",size=1.3,linetype="dashed")
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMin, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMin, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMax, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMax, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
p <- p + theme(legend.position="none")
p <- p + xlab("Difficulty Variable") + ylab("Objective Difficulty") + theme(text = element_text(size=20))
print(p)
}
plot.objective.diff.model.curves.time <- function (DT,fit) {
DTLevel <- unique(DT,by="IDjoueur")
DTLevelOrder = DTLevel[order(abs(niveau))]
joueurMed = DTLevelOrder[1]$IDjoueur
cols <- colorRampPalette(brewer.pal(9,"Spectral"))(11)
for(i in 0:10){
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=i/10)#TODO plusieurs temps
newres = predict(fit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),
IDjoueur = joueurMed,
estDiff = newres,
timeNorm = i/10)
if(i==0){
p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 1,color=cols[i+1]) + xlim(0,1) + ylim(0,1)
} else {
p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 1,size=1,color=cols[i+1])
}
}
p <- p + theme(legend.position="none")
print(p)
}
plot.objective.diff.density <- function (DT) {
p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_bin2d(binwidth=c(1,0.05))
print(p)
}
plot.objective.diff.smooth <- function (DT,selGroup,title) {
if(selGroup != "all")
DT = DT[niveau.group==selGroup]
p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_point(alpha=0.5) + geom_smooth() + xlab("Time (turns)") + ylab("Objective Difficulty") + theme(text = element_text(size=20)) + ggtitle(title)
print(p)
}
```
##Modeling objective difficulty for motor task
```{r modeling.difficulty.motor, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY MOTOR TASK
#------------------------------------------------------
fit.diff.motor <- model.objective.diff(DTM)
DTM <- add.diff.obj(DTM,fit.diff.motor)
DTM <- add.diff.obj.basic(DTM)
DTM <- add.levels(DTM,fit.diff.motor)
DTM <- add.levels.groups(DTM)
print.objective.diff.model(DTM,fit.diff.motor)
plot.objective.diff.model.curves(DTM,fit.diff.motor,0)
plot.objective.diff.model.curves(DTM,fit.diff.motor,1)
plot.objective.diff.model.curves.time(DTM,fit.diff.motor)
plot.objective.diff.density(DTM)
plot.objective.diff.smooth(DTM,"all", "motor all")
plot.objective.diff.smooth(DTM,"bad", "motor bad")
plot.objective.diff.smooth(DTM,"medium", "motor medium")
plot.objective.diff.smooth(DTM,"good", "motor good")
```
##Modeling objective difficulty for sensory task
```{r modeling.difficulty.sensory, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY SENSORY TASK
#------------------------------------------------------
fit.diff.senso <- model.objective.diff(DTS)
DTS <- add.diff.obj(DTS,fit.diff.senso)
DTS <- add.diff.obj.basic(DTS)
DTS <- add.levels(DTS,fit.diff.senso)
DTS <- add.levels.groups(DTS)
print.objective.diff.model(DTS,fit.diff.senso)
plot.objective.diff.model.curves(DTS,fit.diff.senso,0)
plot.objective.diff.model.curves(DTS,fit.diff.senso,1)
plot.objective.diff.model.curves.time(DTS,fit.diff.senso)
plot.objective.diff.density(DTS)
plot.objective.diff.smooth(DTS,"all", "sensory all")
plot.objective.diff.smooth(DTS,"bad", "sensory bad")
plot.objective.diff.smooth(DTS,"medium", "sensory medium")
plot.objective.diff.smooth(DTS,"good", "sensory good")
```
##Modeling objective difficulty for logical task
```{r modeling.difficulty.logical, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY LOGICAL TASK
#------------------------------------------------------
fit.diff.logic <- model.objective.diff(DTL)
DTL <- add.diff.obj(DTL,fit.diff.logic)
DTL <- add.diff.obj.basic(DTL)
DTL <- add.levels(DTL,fit.diff.logic)
DTL <- add.levels.groups(DTL)
print.objective.diff.model(DTL,fit.diff.logic)
plot.objective.diff.model.curves(DTL,fit.diff.logic,0)
plot.objective.diff.model.curves(DTL,fit.diff.logic,1)
plot.objective.diff.model.curves.time(DTL,fit.diff.logic)
plot.objective.diff.density(DTL)
plot.objective.diff.smooth(DTL,"all", "logical all")
plot.objective.diff.smooth(DTL,"bad", "logical bad")
plot.objective.diff.smooth(DTL,"medium", "logical medium")
plot.objective.diff.smooth(DTL,"good", "logical good")
```
```{r modeling.difficulty.merge, echo=FALSE}
#------------------------------------------------------
#       MERGE INTO DTALL
#------------------------------------------------------
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
#------------------------------------------------------
#                  SETUP : PACKAGES
#------------------------------------------------------
require(xlsx)
require(plyr)
require(data.table)
require(ggplot2)
library(car)
require(lme4)
require(lmerTest)
require(Matrix)
library(usdm)
require(lattice)
require(psychometric)
require(MuMIn)
require(pyramid)
require(sjPlot)
require(arm)
library(MASS)
require(MuMIn)
require(Hmisc)
require(RColorBrewer)
#------------------------------------------------------
#              SETUP : UTILS FUNCTIONS
#------------------------------------------------------
format.pval.stars <- function(pv){
pv = signif(pv,digits=2)
if(pv<0.001) {
return(paste(pv,"***"));
}else if(pv<0.01){
return(paste(pv,"**"));
}else  if(pv<0.05){
return(paste(pv,"*"));
}else if(pv<0.1){
return(paste(pv,"."));
}else{
return(paste(pv,":("));
}
return("unable to format pvalue !!");
}
format.pval.only.stars <- function(pv){
pv = signif(pv,digits=2)
if(pv<0.001) {
return("***");
}else if(pv<0.01){
return("**");
}else  if(pv<0.05){
return("*");
}else if(pv<0.1){
return(".");
}else{
return(":(");
}
return("unable to format pvalue !!");
}
format.coef <- function(coef,p.val){
return(paste(signif(coef,digits=3),format.pval.stars(p.val)))
}
remove.na.cols <- function(DT){
return(as.data.table(DT[,which(unlist(lapply(DT, function(x)!all(is.na(x))))),with=F]))
}
remove.na.rows <- function(DT){
return(as.data.table(DT[rowSums(is.na(DT)) != ncol(DT),]))
}
set.empty.to.na <- function(DT){
return(as.data.table(lapply(DT, function(x){replace(x, x=="",NA)})))
}
remove.head.tail <- function(DT,nb,bHead=TRUE){
DT <- as.data.table(DT)
setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
if(bHead)
DT <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
else
DT <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
return(DT)
}
#Plot la courbe de diff pour un joueur
plot.diff.curve <- function (DT,title){
if(nrow(DT) == 0)
return()
df <- data.frame(time=DT$action_de_jeu,
difficulty=DT$difficulty,
bet=DT$miseNorm)
p <- ggplot(df,aes(x=time))
p <- p + geom_step(aes(y=bet,colour="Bet"))
if(length(DT$obj.diff) > 0)
p <- p + geom_step(aes(y=DT$obj.diff,colour="Objective Difficulty"))
else
p <- p + geom_step(aes(y=difficulty,colour="Difficulty parameter"))
p <- p + ylim(0, 1)
p <- p + scale_colour_manual(
values = c("Difficulty parameter" = "red",
"Objective Difficulty" = "pink",
"Bet" = "blue"))
p <- p  +  ggtitle(title);
print(p)
}
#------------------------------------------------------
#        MODELING SUBJECTIVE DIFFICULTY
#------------------------------------------------------
#adding error between subjective difficulty and objective difficulty based on BET
DTAll$subj.diff.mise = 1 - DTAll$miseNorm;
DTAll$error.subj.diff.mise = DTAll$subj.diff.mise - DTAll$obj.diff
DTAll <- DTAll[,error.subj.diff.mise.mean:=mean(error.subj.diff.mise),by=IDjoueur]
#adding error between subjective difficulty and objective difficulty based on CONFIDENCE SCALE
DTAll$subj.diff.confiance = 1 - DTAll$confianceNorm;
DTAll$error.subj.diff.confiance = DTAll$subj.diff.confiance - DTAll$obj.diff
DTAll <- DTAll[,error.subj.diff.confiance.mean:=mean(error.subj.diff.confiance),by=IDjoueur]
#evaluating confidence as a damped over time sum of win and fails;
#each win and fail importance based on objective difficulty at that time
id = DTAll$IDjoueur; # tmp vector faster to read
cur.confidence = 0;
cur.confidence.liss = 0;
lastID <- id[1];
est.confidence <- numeric(nrow(DTAll))
est.confidence[1] = 0;
obj.diff = DTAll$obj.diff
alpha <- 0.9
i = 1
for(i in 2:nrow(DTAll)){
if(id[i] != lastID){
cur.confidence.liss = 0;
}else{
if(gagnant[i-1]){
cur.confidence = obj.diff[i-1];
}else{
cur.confidence = -(1 - obj.diff[i-1]);
}
cur.confidence.liss <- alpha * cur.confidence.liss + cur.confidence;
}
lastID <- id[i];
est.confidence[i] <- cur.confidence.liss;
}
DTAll$est.confidence = est.confidence;
DTAll$est.confidence.norm = exp(DTAll$est.confidence) / (1+exp(DTAll$est.confidence));
#update DTM DTS and DTL
DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]
plot.subjective.difficulty <- function(DT,selGroup,title){
print(selGroup)
# Lien entre mise normalisée et difficultée estimée (hard / easy effect)
obj.diff.quants = seq(0,1,1/16)#quantile(DT$obj.diff, probs=(seq(0,1,0.05)))
nb.bins = length(obj.diff.quants)-1
subj.diff.med = numeric(nb.bins)
obj.diff.bin = numeric(nb.bins)
obj.diff.bin.cur = 0;
test.pvals = numeric(nb.bins)
conf.min = numeric(nb.bins)
conf.max = numeric(nb.bins)
nb.vals = numeric(nb.bins)
shapes =  numeric(nb.bins)
delta.obj.subj = numeric(nb.bins)
hist(DT$obj.diff)
for(i in 1:nb.bins){
#obj.diff.bin.cur = round(i/10,1)
#subj.diff = DT[round(obj.diff,1)==obj.diff.bin.cur]$subj.diff.mise
obj.diff.bin.cur = (obj.diff.quants[i] + obj.diff.quants[i+1])/2.0
#subj.diff = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]$subj.diff.mise
DTLoc = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]
if(selGroup != "all")
DTLoc = DTLoc[niveau.group==selGroup]
DTLoc = DTLoc[,.(confiance.mean=mean(subj.diff.confiance)),by=IDjoueur]
subj.diff = DTLoc$confiance.mean
obj.diff.bin[i] = obj.diff.bin.cur
subj.diff.med[i] = NA
test.pvals[i] = NA
conf.min[i] = NA
conf.max[i] = NA
delta.obj.subj[i] = NA
shapes[i] = 16
nb.vals[i] = length(subj.diff)
if(nb.vals[i] > 1){
try.res = try(test.res <- wilcox.test(subj.diff,mu = obj.diff.bin.cur,conf.int=T))
if (class(try.res) != "try-error"){
#print(test.res)
#hist(subj.diff)
test.pvals[i] = format.pval.stars(test.res$p.value)
if(test.res$p.value < 0.05)
shapes[i] = 24
#subj.diff.med[i] = mean(subj.diff)
subj.diff.med[i] = test.res$estimate
conf.min[i] = test.res$conf.int[1]
conf.max[i] = test.res$conf.int[2]
delta.obj.subj[i] = signif(subj.diff.med[i] - obj.diff.bin.cur,digit=2)
}
}
}
#print table of pvalues
print(data.table(obj.diff.bin=obj.diff.bin,delta.obj.subj=delta.obj.subj,n=nb.vals,pval=test.pvals))
#summary
print("mean and sd of nb players per bin")
DTNbVals = data.table(nb = nb.vals, pval=test.pvals)
print(DTNbVals[!is.na(pval)])
print(signif(mean(DTNbVals[!is.na(pval)]$nb),digits=3))
print(signif(sd(DTNbVals[!is.na(pval)]$nb),digits=3))
#kernel smooth
subj.diff.smooth <- ksmooth(x=DT$obj.diff,y=DT$subj.diff.confiance,bandwidth = 0.2)
DTSmooth = data.table(x=subj.diff.smooth$x,y=subj.diff.smooth$y)
DTPlot = data.table(obj.diff=obj.diff.bin,subj.diff=subj.diff.med, shapes=shapes)
p = ggplot() + ggtitle(title) +
#       geom_line(aes(x=DTPouet$x,y=DTPouet$y))+
geom_point(aes(x=DTPlot$obj.diff,y=DTPlot$subj.diff),alpha = 1, size = 3, shape=DTPlot$shapes) +
xlim(0,1)+
ylim(0,1)+
geom_errorbar(aes(x=DTPlot$obj.diff, ymin=conf.min, ymax=conf.max), width=.01,color="red")  +
geom_abline(intercept = 0, slope = 1, color="blue") +
xlab("Objective Difficulty") + ylab("Subjective Difficulty") + theme(text = element_text(size=15))
print(p)
}
plot.subjective.difficulty(DTAll,"all", "All tasks, all groups")
plot.subjective.difficulty(DTAll,"good", "All tasks, good")
plot.subjective.difficulty(DTAll,"medium", "All tasks, medium")
plot.subjective.difficulty(DTAll,"bad", "All tasks, bad")
plot.subjective.difficulty(DTM,"all", "Motor, all")
plot.subjective.difficulty(DTM,"good", "Motor, good")
plot.subjective.difficulty(DTM,"medium", "Motor, medium")
plot.subjective.difficulty(DTM,"bad", "Motor, bad")
plot.subjective.difficulty(DTS,"all","Sensory, all")
plot.subjective.difficulty(DTS,"good","Sensory, good")
plot.subjective.difficulty(DTS,"medium","Sensory, medium")
plot.subjective.difficulty(DTS,"bad","Sensory, bad")
plot.subjective.difficulty(DTL,"all","Logical, all")
plot.subjective.difficulty(DTL,"good","Logical, good")
plot.subjective.difficulty(DTL,"medium","Logical, medium")
plot.subjective.difficulty(DTL,"bad","Logical, bad")
View(DTM)
