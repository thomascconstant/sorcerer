#logit de la difficulte supposée sur l'échec constaté
mylogit <- glm(perdant ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
print(summary(mylogit));
sample = data.frame(difficulty=DTLoc$difficulty);
DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response");
#=================== hard/easy effect
#------------------ tous les jeux
maxEstDiff <- max(DTLoc$estDiff)
minEstDiff <- min(DTLoc$estDiff)
intervalEstDiff <- (maxEstDiff - minEstDiff)/10
#------------------ difficulté logique
DTLocL <- DTLoc[nom_du_jeu == "Logique2"]
maxEstDiffL <- max(DTLocL$estDiff)
minEstDiffL <- min(DTLocL$estDiff)
intervalEstDiffL <- (maxEstDiffL - minEstDiffL)/10
ggplot(DTLocL, aes(x=factor(estDiff), y=evalDiff)) +
stat_summary(fun.y="mean", geom="bar") +
stat_summary(aes(label=round(..y..,2)), fun.y=mean, geom="text", size=6,
vjust = -0.5)
ggplot(DTL, aes(x=estDiff, y=evalDiff)) +
stat_summary(fun.y="mean", geom="bar") +
stat_summary(aes(label=round(..y..,2)), fun.y=mean, geom="text", size=6,
vjust = -0.5) +
geom_abline(intercept=-1, color = "red", size=1)
#------------------ difficulté sensorielle
DTLocS <- DTLoc[nom_du_jeu == "Sensoriel"]
maxEstDiffS <- max(DTLocS$estDiff)
minEstDiffS <- min(DTLocS$estDiff)
ggplot(DTLocS, aes(x=factor(estDiff), y=evalDiff)) +
stat_summary(fun.y="mean", geom="bar") +
stat_summary(aes(label=round(..y..,2)), fun.y=mean, geom="text", size=6,
vjust = -0.5)
ggplot(DTS, aes(x=estDiff, y=evalDiff)) +
stat_summary(fun.y="mean", geom="bar") +
stat_summary(aes(label=round(..y..,2)), fun.y=mean, geom="text", size=6,
vjust = -0.5)
#------------------ difficulté motrice
DTLocM <- DTLoc[nom_du_jeu == "Motrice"]
maxEstDiffM <- max(DTLocM$estDiff)
minEstDiffM <- min(DTLocM$estDiff)
ggplot(DTLocM, aes(x=factor(estDiff), y=evalDiff)) +
stat_summary(fun.y="mean", geom="bar") +
stat_summary(aes(label=round(..y..,2)), fun.y=mean, geom="text", size=6,
vjust = -0.5)
ggplot(DTM, aes(x=estDiff, y=evalDiff)) +
stat_summary(fun.y="mean", geom="bar") +
stat_summary(aes(label=round(..y..,2)), fun.y=mean, geom="text", size=6,
vjust = -0.5)
DTLocEvalDiffLogique <- DTLoc[c(nom_du_jeu == "Logique2",evalDiff)]
analyseHardEasyEffect <- function(DTParam){
res <- numeric(11)
coef <- numeric(11)
nb <- numeric(11)
nb2 <- numeric(11)
pv1 <- numeric(11)
pv2 <- numeric(11)
dObj <- numeric(11)
i = 0;
while(i<=10){
diff=i/10;
print(diff)
DTLoc = DTParam[which(difficulty >= diff-0.01 & difficulty <= diff+0.01 & action_de_jeu > 2)]
DTLoc$miseBin = ifelse(DTLoc$mise>4, 1, 0);
# DTLoc[,miseBin:= -1];
# DTLoc[mise > 4,miseBin := 1];
# DTLoc[mise < 4,miseBin := 0];
# DTLoc = DTLoc[miseBin != -1];
#
if(nrow(DTLoc) > 30){
plot(x=DTLoc$resLisse, y=DTLoc$miseNorm, main=paste(diff,signif(unique(DTLoc$estDiff),digits=2)))
#
# fit <- glm(DTLoc$miseNorm ~ DTLoc$resLisse);
#
#
# fitg <- glm(miseBin ~ resLisse, data = DTLoc, family = "binomial"(link = "logit"))
# sample = data.frame(resLisse=seq(0, 1, 0.05))
# newres = predict(fitg, newdata = sample, type = "response")
# points(x=sample$resLisse,y=newres,col="red")
# print(summary(fitg))
# abline(a =fit$coefficients[1], b=fit$coefficients[2], col="green")
# res[i+1] = signif(fit$coefficients[2],digits=2);
#
# #print(unlist(summary(fit)));
# pv1[i+1] = echoPValue(unlist(summary(fitg))$coefficients7)
# pv2[i+1] = echoPValue(unlist(summary(fitg))$coefficients8)
fit <- lm(DTLoc$miseNorm ~ DTLoc$resLisse);
abline(a =fit$coefficients[1], b=fit$coefficients[2], col="green")
print(summary(fit))
print(qqPlot(residuals(fit)))
pv1[i+1] = echoPValue(summary(fit)$coefficients[2,4]);
pv2[i+1] = echoPValue(shapiro.test(residuals(fit))$p.value);
res[i+1] =  signif(summary(fit)$r.squared,digits=2);
coef[i+1] =  signif(summary(fit)$coefficients[2,1],digits=2)
#print(echoPValue(summary(fit)$coefficients[,4]))
#print(summary(fit)$r.squared)
print("next")
}else{
res[i+1] = NA;
pv1[i+1] = NA;
pv2[i+1] = NA;
coef[i+1] = NA;
}
nb[i+1] = nrow(DTLoc);
nb2[i+1] = length(unique(DTLoc$IDjoueur))
dObj[i+1] = DTLoc$estDiff[1];
i=i+1
}
resTable = data.table(NbObservations = nb);
#  resTable[,NbObservations := nb];
resTable[,DiffObj := dObj];
resTable[,NbJoueurs := nb2];
resTable[,Coef := coef];
resTable[,R2 := res];
resTable[,pValueModele := pv1];
resTable[,normResidus := pv2];
return(resTable)
}
#=================== mise par rapport à la difficulté
model <- lmer(DTLoc$mise ~ DTLoc$difficulty + (1 | DTLoc$IDjoueur))
summary(model)
r.squaredGLMM(model)
predict(model)
#------------------ mise par rapport à la difficulté logique
DTLocL <- DTLoc[nom_du_jeu == "Logique2"]
model <- lmer(DTLocL$mise ~ DTLocL$difficulty + (1 | DTLocL$IDjoueur))
summary(model)
r.squaredGLMM(model)
predict(model)
#------------------ mise par rapport à la difficulté motrice
DTLocM <- DTLoc[nom_du_jeu == "Motrice"]
model <- lmer(DTLocM$mise ~ DTLocM$difficulty + (1 | DTLocM$IDjoueur))
summary(model)
r.squaredGLMM(model)
predict(model)
#------------------ mise par rapport à la difficulté sensorielle
DTLocS <- DTLoc[nom_du_jeu == "Sensoriel"]
model <- lmer(DTLocS$mise ~ DTLocS$difficulty + (1 | DTLocS$IDjoueur))
summary(model)
r.squaredGLMM(model)
predict(model)
# install.packages("sjPlot")
# install.packages("arm")
# require(sjPlot)
# require(arm)
# sjp.lmer(model)
#
# plot(x=DTLoc$erreurMise, y=DTLoc$difficulty)
# abline(h=mean(DTLoc$erreurMise),col = "blue", lwd = 2)
#
# ggplot(data=DTLoc, aes(miseNorm,difficulty))
# ggplot(model)
# #install.packages("multcomp")
# library(multcomp)
# tmp <- as.data.frame(confint(glht(model))$confint)
# tmp$Comparison <- rownames(tmp)
# ggplot(tmp, aes(x = Comparison, y = Estimate, ymin = lwr, ymax = upr)) + geom_errorbar() + geom_point()
#
#
# install.packages("ggplot2")
# library(ggplot2)
#=================== erreur mise dans le temps
model <- lmer(DTLoc$erreurMise ~ DTLoc$action_de_jeu + (1 | DTLoc$IDjoueur))
summary(model) #nope
r.squaredGLMM(model)
plot(DTLoc$erreurMise ~ DTLoc$action_de_jeu)
#=================== erreur mise selon profil de joueur de jeu vidéo du participant
model <- lmer(DTLoc$erreurMise ~ DTLoc$maxProfilJoueurJeuVideo + (1 | DTLoc$IDjoueur))
model <- aov(DTLoc$erreurMise ~ DTLoc$maxProfilJoueurJeuVideo)
summary(model) #nope
r.squaredGLMM(model)
#------------------ erreur mise par rapport à la difficulté (selon profil jeu vidéo gamer du participant)
DTLocGamer <- DTLoc[maxProfilJoueurJeuVideo>=3]
model <- lmer(DTLocGamer$erreurMise ~ DTLocGamer$difficulty + (1 | DTLocGamer$IDjoueur))
summary(model)
r.squaredGLMM(model)
#------------------ erreur mise par rapport à la difficulté (selon profil jeu vidéo non-gamer du participant)
DTLocNoGamer <- DTLoc[maxProfilJoueurJeuVideo<3]
model <- lmer(DTLocNoGamer$erreurMise ~ DTLocNoGamer$difficulty + (1 | DTLocNoGamer$IDjoueur))
summary(model) #***, mais effet ridicule et R2 léger
r.squaredGLMM(model)
#=================== erreur mise selon profil de joueur de jeu de plateau du participant
model <- lmer(DTLoc$erreurMise ~ DTLoc$maxProfilJoueurJeuPlateau + (1 | DTLoc$IDjoueur))
model <- aov(DTLoc$erreurMise ~ DTLoc$maxProfilJoueurJeuPlateau)
summary(model) #nope
r.squaredGLMM(model)
#=================== erreur mise selon profil de joueur de jeu d'argent du participant
model <- lmer(DTLoc$erreurMise ~ DTLoc$maxProfilJoueurJeuArgent + (1 | DTLoc$IDjoueur))
model <- aov(DTLoc$erreurMise ~ DTLoc$maxProfilJoueurJeuArgent)
summary(model) #nope
r.squaredGLMM(model)
#=================== erreur mise selon profil risquophobe/risquophile du participant
model <- lmer(DTLoc$erreurMise ~ DTLoc$sumProfilRA + (1 | DTLoc$IDjoueur))
summary(model) #pas d'impact lié au profil risquophobe/phile
r.squaredGLMM(model)
#------------------ erreur mise par rapport à la difficulté (selon profil risquophobe du participant)
DTLocRisk <- DTLoc[sumProfilRA>=6]
model <- lmer(DTLocRisk$erreurMise ~ DTLocRisk$difficulty + (1 | DTLocRisk$IDjoueur))
summary(model) #rassurant, être risquophobe n'a pas d'impact, on peut garder les données
r.squaredGLMM(model)
#------------------ erreur mise par rapport à la difficulté (selon profil risquophile du participant)
DTLocNoRisk <- DTLoc[sumProfilRA<=5]
model <- lmer(DTLocNoRisk$erreurMise ~ DTLocNoRisk$difficulty + (1 | DTLocNoRisk$IDjoueur))
summary(model) #rassurant, être risquophile n'a pas d'impact, on peut garder les données
r.squaredGLMM(model)
#=================== erreur mise selon sexe du participant
model <- aov(DTLoc$erreurMise ~ DTLoc$sexe)
summary(model) #pas d'impact lié au sexe
r.squaredGLMM(model)
#------------------ erreur mise par rapport à la difficulté (selon sexe du participant)
DTLocWomen <- DTLoc[sexe==1]
model <- lmer(DTLocWomen$erreurMise ~ DTLocWomen$difficulty + (1 | DTLocWomen$IDjoueur))
summary(model)
r.squaredGLMM(model) #r2 non révélateur
DTLocMen <- DTLoc[sexe==0]
model <- lmer(DTLocMen$erreurMise ~ DTLocMen$difficulty + (1 | DTLocMen$IDjoueur))
summary(model)
r.squaredGLMM(model) #r2 non révélateur
#=================== erreur mise selon niveau d'étude du participant
#A REPRENDRE
# DTLocBac2Plus <- DTLoc[niveauEtude>=4]
# model <- lmer(DTLocBac2Plus$erreurMise ~ DTLocBac2Plus$meanProfilJoueur + (1 | DTLocBac2Plus$IDjoueur))
# summary(model) #pas d'impact lié à un niveau d'étude >= à Bac+2
#
# DTLocBacPlus <- DTLoc[niveauEtude>=3]
# model <- lmer(DTLocBacPlus$erreurMise ~ DTLocBacPlus$meanProfilJoueur + (1 | DTLocBacPlus$IDjoueur))
# summary(model) #pas d'impact lié à un niveau d'étude >= à Bac
#
# DTLocNoBac <- DTLoc[niveauEtude<3]
# model <- lmer(DTLocNoBac$erreurMise ~ DTLocNoBac$meanProfilJoueur + (1 | DTLocNoBac$IDjoueur))
# summary(model) #pas d'impact lié à un niveau d'étude < au Bac (rassurant, vu le nombre de participants)
#
#=================== erreur mise selon âge du participant
#A REPRENDRE
# DTLocMoins15 <- DTLoc[age<=15]
# model <- lmer(DTLocMoins15$erreurMise ~ DTLocMoins15$meanProfilJoueur + (1 | DTLocMoins15$IDjoueur))
# summary(model) #pas d'impact pour les participants de 15ans ou moins (rassurant, c'est la majorité des joueurs)
#
# DTLocPlus15 <- DTLoc[age>15]
# model <- lmer(DTLocPlus15$erreurMise ~ DTLocPlus15$meanProfilJoueur + (1 | DTLocPlus15$IDjoueur))
# summary(model) #pas d'impact pour les participants strictement > à 15ans
#
#=================== autres tests
fit <- glm(miseBin ~ nbWin + nbFail + difficulty, data=DTLoc);
fit <- glm(miseNorm ~ lastWin + lastFail + difficulty, data=DTLoc);
confint(fit)
fit <- glm(miseNorm ~ resLisse + difficulty, data=DTLoc);
hist(DTLoc$resLisse)
summary(fit)
dotplot(ranef(fit))
ran = as.data.table()
hist(class(ranef(fit)))
ranef(fit)
fixef(fit)
length(unlist((ranef(fit))))
plot(fit, which=1)
}
# DTLoc1 = DTL;
#
# res <- numeric(11)
# nb <- numeric(11)
# i = 0;
# while(i<=10){
#   diff=i/10;
#   print(diff)
#   DTLoc = DTLoc1[which(difficulty >= diff-0.01 & difficulty <= diff+0.01  & action_de_jeu > 5)]
#   if(nrow(DTLoc) > 20){
#     plot(x=DTLoc$resLisse, y=DTLoc$erreurDiffConfiance, main=paste(diff,signif(unique(DTLoc$estDiff),digits=2)))
#     fit <- glm(DTLoc$erreurDiffConfiance ~ DTLoc$resLisse);
#     DTLoc$miseBin = ifelse(DTLoc$mise>4, 1, 0)
#     fitg <- glm(miseBin ~ resLisse, data = DTLoc, family = "binomial"(link = "logit"))
#     sample = data.frame(resLisse=seq(0, 1, 0.05))
#     newres = predict(fitg, newdata = sample, type = "response")
#     points(x=sample$resLisse,y=newres,col="red")
#     print(summary(fitg))
#     abline(a =fit$coefficients[1], b=fit$coefficients[2], col="green")
#     res[i+1] = fit$coefficients[2];
#     nb[i+1] = nrow(DTLoc);
#   }else{
#     res[i+1] = NA;
#   }
#
#   i=i+1
# }
# print(nb)
# print(res)
analyseParDifficute <- function(DTParam){
res <- numeric(11)
coef <- numeric(11)
nb <- numeric(11)
nb2 <- numeric(11)
pv1 <- numeric(11)
pv2 <- numeric(11)
dObj <- numeric(11)
i = 0;
while(i<=10){
diff=i/10;
print(diff)
DTLoc = DTParam[which(difficulty >= diff-0.01 & difficulty <= diff+0.01  & action_de_jeu > 2)]
DTLoc$miseBin = ifelse(DTLoc$mise>4, 1, 0);
# DTLoc[,miseBin:= -1];
# DTLoc[mise > 4,miseBin := 1];
# DTLoc[mise < 4,miseBin := 0];
# DTLoc = DTLoc[miseBin != -1];
#
if(nrow(DTLoc) > 30){
plot(x=DTLoc$resLisse, y=DTLoc$miseNorm, main=paste(diff,signif(unique(DTLoc$estDiff),digits=2)))
#
# fit <- glm(DTLoc$miseNorm ~ DTLoc$resLisse);
#
#
# fitg <- glm(miseBin ~ resLisse, data = DTLoc, family = "binomial"(link = "logit"))
# sample = data.frame(resLisse=seq(0, 1, 0.05))
# newres = predict(fitg, newdata = sample, type = "response")
# points(x=sample$resLisse,y=newres,col="red")
# print(summary(fitg))
# abline(a =fit$coefficients[1], b=fit$coefficients[2], col="green")
# res[i+1] = signif(fit$coefficients[2],digits=2);
#
# #print(unlist(summary(fit)));
# pv1[i+1] = echoPValue(unlist(summary(fitg))$coefficients7)
# pv2[i+1] = echoPValue(unlist(summary(fitg))$coefficients8)
fit <- lm(DTLoc$miseNorm ~ DTLoc$resLisse);
abline(a =fit$coefficients[1], b=fit$coefficients[2], col="green")
print(summary(fit))
print(qqPlot(residuals(fit)))
pv1[i+1] = echoPValue(summary(fit)$coefficients[2,4]);
pv2[i+1] = echoPValue(shapiro.test(residuals(fit))$p.value);
res[i+1] =  signif(summary(fit)$r.squared,digits=2);
coef[i+1] =  signif(summary(fit)$coefficients[2,1],digits=2)
#print(echoPValue(summary(fit)$coefficients[,4]))
#print(summary(fit)$r.squared)
print("next")
}else{
res[i+1] = NA;
pv1[i+1] = NA;
pv2[i+1] = NA;
coef[i+1] = NA;
}
nb[i+1] = nrow(DTLoc);
nb2[i+1] = length(unique(DTLoc$IDjoueur))
dObj[i+1] = DTLoc$estDiff[1];
i=i+1
}
resTable = data.table(NbObservations = nb);
#  resTable[,NbObservations := nb];
resTable[,DiffObj := dObj];
resTable[,NbJoueurs := nb2];
resTable[,Coef := coef];
resTable[,R2 := res];
resTable[,pValueModele := pv1];
resTable[,normResidus := pv2];
return(resTable)
}
print("Logique")
resLog = analyseParDifficute(DTL);
DTParam <- DTL
res <- numeric(10)
nb <- numeric(10)
i = 1;
while(i<=10){
diff=i/10;
DTLoc = DTParam[which(estDiff >= diff-0.1 & estDiff < diff+0.1)]
res[i] = mean(DTLoc$miseNorm);
nb[i] = nrow(DTLoc);
i=i+1
#print(shapiro.test(DTLoc$miseNorm));
#print(hist(DTLoc$miseNorm))
}
print(res)
print(nb)
testPlot = data.table();
DTParam <- DTL
res <- numeric(10)
nb <- numeric(10)
diffVec <- numeric(10)
i = 1;
while(i<=10){
diff=i/10;
DTLoc = DTParam[which(estDiff >= diff-0.1 & estDiff < diff+0.1)]
res[i] = mean(DTLoc$miseNorm);
nb[i] = nrow(DTLoc);
diffVec[i] = diff;
i=i+1
#print(shapiro.test(DTLoc$miseNorm));
#print(hist(DTLoc$miseNorm))
}
print(res)
print(nb)
testPlot$x = diffVec;
testPlot = data.table(x=diffVec);
testPlot$y = res;
plot(testPlot)
plot(testPlot)
DTParam <- DTL
res <- numeric(10)
nb <- numeric(10)
diffVec <- numeric(10)
i = 1;
while(i<=10){
diff=i/10;
DTLoc = DTParam[which(estDiff >= diff-0.1 & estDiff < diff+0.1)]
res[i] = median(DTLoc$miseNorm);
nb[i] = nrow(DTLoc);
diffVec[i] = diff;
i=i+1
#print(shapiro.test(DTLoc$miseNorm));
#print(hist(DTLoc$miseNorm))
}
print(res)
print(nb)
testPlot = data.table(x=diffVec);
testPlot$y = res;
plot(testPlot)
plot(testPlot)
DTParam <- DTL
res <- numeric(10)
nb <- numeric(10)
diffVec <- numeric(10)
i = 1;
while(i<=10){
diff=i/10;
DTLoc = DTParam[which(estDiff >= diff-0.1 & estDiff < diff+0.1)]
res[i] = mean(DTLoc$miseNorm);
nb[i] = nrow(DTLoc);
diffVec[i] = diff;
i=i+1
#print(shapiro.test(DTLoc$miseNorm));
#print(hist(DTLoc$miseNorm))
}
print(res)
print(nb)
testPlot = data.table(x=diffVec);
testPlot$y = res;
plot(testPlot)
plot(testPlot)
plot(testPlot,ylim=c(0, 1))
plot(testPlot,ylim=c(0, 1))
abline(a=-1,b=1)
abline(a=1,b=-1)
plot(testPlot,ylim=c(0, 1))
abline(a=1,b=-1)
plot(testPlot,ylim=c(0, 1))
abline(a=1,b=-1)
plot(testPlot,ylim=c(0, 1),xlim=c(0, 1))
abline(a=1,b=-1)
plot(testPlot,ylim=c(0, 1),xlim=c(0, 1))
abline(a=1,b=-1)
DTParam <- DTM
res <- numeric(10)
nb <- numeric(10)
diffVec <- numeric(10)
i = 1;
while(i<=10){
diff=i/10;
DTLoc = DTParam[which(estDiff >= diff-0.1 & estDiff < diff+0.1)]
res[i] = mean(DTLoc$miseNorm);
nb[i] = nrow(DTLoc);
diffVec[i] = diff;
i=i+1
#print(shapiro.test(DTLoc$miseNorm));
#print(hist(DTLoc$miseNorm))
}
print(res)
print(nb)
testPlot = data.table(x=diffVec);
testPlot$y = res;
plot(testPlot,ylim=c(0, 1),xlim=c(0, 1))
abline(a=1,b=-1)
plot(testPlot,ylim=c(0, 1),xlim=c(0, 1))
abline(a=1,b=-1)
DTParam <- DTS
res <- numeric(10)
nb <- numeric(10)
diffVec <- numeric(10)
i = 1;
while(i<=10){
diff=i/10;
DTLoc = DTParam[which(estDiff >= diff-0.1 & estDiff < diff+0.1)]
res[i] = mean(DTLoc$miseNorm);
nb[i] = nrow(DTLoc);
diffVec[i] = diff;
i=i+1
#print(shapiro.test(DTLoc$miseNorm));
#print(hist(DTLoc$miseNorm))
}
print(res)
print(nb)
testPlot = data.table(x=diffVec);
testPlot$y = res;
plot(testPlot,ylim=c(0, 1),xlim=c(0, 1))
abline(a=1,b=-1)
DTParam <- DTL
res <- numeric(10)
nb <- numeric(10)
diffVec <- numeric(10)
i = 1;
while(i<=10){
diff=i/10;
DTLoc = DTParam[which(estDiff >= diff-0.1 & estDiff < diff+0.1)]
res[i] = mean(DTLoc$miseNorm);
nb[i] = nrow(DTLoc);
diffVec[i] = diff;
i=i+1
#print(shapiro.test(DTLoc$miseNorm));
#print(hist(DTLoc$miseNorm))
}
print(res)
print(nb)
testPlot = data.table(x=diffVec);
testPlot$y = res;
plot(testPlot,ylim=c(0, 1),xlim=c(0, 1))
abline(a=1,b=-1)
