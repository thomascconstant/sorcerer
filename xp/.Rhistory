DTLoc$evalDiff <- 1 - DTLoc$miseNorm;
#On ajoute une colonne de la difficulte estimee, a partir d'un
#logit de la difficulte supposée sur l'échec constaté
mylogit <- glm(perdant ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
sample = data.frame(difficulty=DTLoc$difficulty);
DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response");
#erreur d'estimation de la difficulte par le joueur (exces de confiance ?)
DTLoc$erreurdiff <- DTLoc$evalDiff - DTLoc$estDiff;
#nombre de fail consecutifs
DTNbFail <- DTLoc[1,]
nbFailCpt = 0;#DTLoc[1,perdant]
DTNbFail <- cbind(DTNbFail,data.table(nbFail=nbFailCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 0){
nbFailCpt = nbFailCpt+1;
}else{
nbFailCpt = 0;
}
DTNbFail <- rbind(DTNbFail,cbind(DTLoc[i,],data.table(nbFail=nbFailCpt)))
}
DTLoc <- DTNbFail
#nombre de wins consecutifs
DTNbWin <- DTLoc[1,]
nbWinCpt = 0;#DTLoc[1,gagnant]
DTNbWin <- cbind(DTNbWin,data.table(nbWin=nbWinCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 1){
nbWinCpt = nbWinCpt+1;
}else{
nbWinCpt = 0;
}
DTNbWin <- rbind(DTNbWin,cbind(DTLoc[i,],data.table(nbWin=nbWinCpt)))
}
DTLoc <- DTNbWin
#On calcule une somme lissée des echecs et succes
DTResLisse <- DTLoc[1,];
resLisseCur <- 0;
DTResLisse <- cbind(DTResLisse,data.table(resLisse=resLisseCur));
alpha <- 0.5;
for(i in 2:nrow(DTLoc)){
res <- (DTLoc[i-1,gagnant]*2)-1;
resLisseCur <- alpha * resLisseCur + res;
DTResLisse <- rbind(DTResLisse,cbind(DTLoc[i,],data.table(resLisse=resLisseCur)));
}
DTLoc <- DTResLisse
print("Anova res lisse")
fit <- aov(erreurdiff ~ resLisse, data=DTLoc)
sum_fit1 = unlist(summary(fit))
print("Anova nbWin")
fit <- aov(erreurdiff ~ nbWin, data=DTLoc)
sum_fit2 = unlist(summary(fit))
print("Anova nbFail")
fit <- aov(erreurdiff ~ nbFail, data=DTLoc)
sum_fit3 = unlist(summary(fit))
#print(summary(fit))
print(sum_fit1["Pr(>F)1"]);
print(sum_fit2["Pr(>F)1"]);
print(sum_fit3["Pr(>F)1"]);
print("Regression linéaire")
#fitl <- glm(DTLoc$erreurdiff ~ DTLoc$resLisse)
#abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
#print(summary(fitl))
#plot(fitl)
library(Defaults)
setDefaults("source",echo=FALSE)
file = "./log_thomas_XPFINALES.txt"
csv.data <- read.csv(file,header=TRUE,sep=";")
DT <- as.data.table(csv.data)
DTM <- csv.data[which(csv.data$nom_du_jeu=="Motrice"),]
DTM <- as.data.table(DTM)
DTM$difficulty <-  (DTM$difficulty)/ abs(max(DTM$difficulty)) #normalisation difficulte
DTLoc <- DT;
trace=FALSE;
titre = "titre";
#echec au lieu de succes pour diff c'est mieux
DTLoc$perdant <- 1-DTLoc$gagnant;
#normalisation de la mise
DTLoc$miseNorm <- DTLoc$mise / 7;
#difficulte évaluée par le joueur
DTLoc$evalDiff <- 1 - DTLoc$miseNorm;
#On ajoute une colonne de la difficulte estimee, a partir d'un
#logit de la difficulte supposée sur l'échec constaté
mylogit <- glm(perdant ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
sample = data.frame(difficulty=DTLoc$difficulty);
DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response");
#erreur d'estimation de la difficulte par le joueur (exces de confiance ?)
DTLoc$erreurdiff <- DTLoc$evalDiff - DTLoc$estDiff;
#nombre de fail consecutifs
DTNbFail <- DTLoc[1,]
nbFailCpt = 0;#DTLoc[1,perdant]
DTNbFail <- cbind(DTNbFail,data.table(nbFail=nbFailCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 0){
nbFailCpt = nbFailCpt+1;
}else{
nbFailCpt = 0;
}
DTNbFail <- rbind(DTNbFail,cbind(DTLoc[i,],data.table(nbFail=nbFailCpt)))
}
DTLoc <- DTNbFail
#nombre de wins consecutifs
DTNbWin <- DTLoc[1,]
nbWinCpt = 0;#DTLoc[1,gagnant]
DTNbWin <- cbind(DTNbWin,data.table(nbWin=nbWinCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 1){
nbWinCpt = nbWinCpt+1;
}else{
nbWinCpt = 0;
}
DTNbWin <- rbind(DTNbWin,cbind(DTLoc[i,],data.table(nbWin=nbWinCpt)))
}
DTLoc <- DTNbWin
#On calcule une somme lissée des echecs et succes
DTResLisse <- DTLoc[1,];
resLisseCur <- 0;
DTResLisse <- cbind(DTResLisse,data.table(resLisse=resLisseCur));
alpha <- 0.5;
for(i in 2:nrow(DTLoc)){
res <- (DTLoc[i-1,gagnant]*2)-1;
resLisseCur <- alpha * resLisseCur + res;
DTResLisse <- rbind(DTResLisse,cbind(DTLoc[i,],data.table(resLisse=resLisseCur)));
}
DTLoc <- DTResLisse
print("Anova res lisse")
fit <- aov(erreurdiff ~ resLisse, data=DTLoc)
sum_fit1 = unlist(summary(fit))
print("Anova nbWin")
fit <- aov(erreurdiff ~ nbWin, data=DTLoc)
sum_fit2 = unlist(summary(fit))
print("Anova nbFail")
fit <- aov(erreurdiff ~ nbFail, data=DTLoc)
sum_fit3 = unlist(summary(fit))
#print(summary(fit))
print(sum_fit1["Pr(>F)1"]);
print(sum_fit2["Pr(>F)1"]);
print(sum_fit3["Pr(>F)1"]);
print("Regression linéaire")
#fitl <- glm(DTLoc$erreurdiff ~ DTLoc$resLisse)
#abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
#print(summary(fitl))
#plot(fitl)
source('~/sorcerer/xp/test.R')
source('~/sorcerer/xp/test.R', echo=TRUE)
print(sum_fit1["Pr(>F)1"]);
print(sum_fit2["Pr(>F)1"]);
print(sum_fit3["Pr(>F)1"]);
<p align = "justify" >&nbsp;&nbsp; $d_{og}$ a une faiblesse: elle est calculée sur l'ensemble du groupe et donc ne tient pas compte du niveau spécifique de chaque joueur, elle s'éloigne donc de la difficulté réelle $d_{r}$ pour les joueurs qui sortent de la moyenne du groupe, bons ou mauvais. Donc plus un joueur s'éloigne de la moyenne des joueurs, plus l'erreur d'évaluation de la difficulté va être importante: même si $d_{s}$ est parfaite, $\mid d_{s}-d_{og} \mid$ va augmenter car $d_{og}$ devient de plus en plus fausse. Autrement dit, la correlation entre $n_{win}$ et $\epsilon$ provient elle d'une erreur sur la difficulté subjective (exces de confiance) ou sur la difficulté objective. Car justement, plus un joueur est bon (ou mauvais) plus il a de chance d'avoir des suites de succès (ou d'échecs), avant que la difficulté se soit adaptée, ce qui pourrait expliquer une corrélation entre $d_{og}$ et $n_{win}$.</p>
#setwd("C:/Users/Thomas Constant/Source/Repos/sorcerer/xp")
#install.packages("rmarkdown")
#setwd("C:/Users/Thomas Constant/Source/Repos/sorcerer/xp")
#install.packages("rmarkdown")
#install.packages("data.table")
#install.packages("ggplot2")
require(data.table)
require(ggplot2)
#----------------------------------- configuration
useMotrice = TRUE
useSensorielle = TRUE
useLogique = TRUE
drawLogit = TRUE
removeTenFirst = FALSE
file = "./log_thomas_XPFINALES.txt"
#file = "./log_thomas_correct_motrice.txt"
#---------------------------------- fonctions
addVariables <- function(DTLoc,trace = FALSE,titre="noTitle"){
#echec au lieu de succes pour diff c'est mieux
DTLoc$perdant <- 1-DTLoc$gagnant;
#normalisation de la mise
DTLoc$miseNorm <- DTLoc$mise / 7;
#difficulte évaluée par le joueur
DTLoc$evalDiff <- 1 - DTLoc$miseNorm;
#On ajoute une colonne de la difficulte estimee, a partir d'un
#logit de la difficulte supposée sur l'échec constaté
mylogit <- glm(perdant ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
sample = data.frame(difficulty=DTLoc$difficulty);
DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response");
if(trace){
sample = data.frame(difficulty=seq(0, 1, 0.05))
newres = predict(mylogit, newdata = sample, type = "response")
plot(DTLoc$difficulty, DTLoc$perdant, main=titre, xlab="Difficulté hypothétique",  ylab="Difficulté objective (estimée)",  col=rgb(0,100,0,100,maxColorValue=255))
points(data.frame(sample,newres), type="o")
}
#erreur d'estimation de la difficulte par le joueur (exces de confiance ?)
DTLoc$erreurdiff <- DTLoc$evalDiff - DTLoc$estDiff;
#nombre de fail consecutifs
DTNbFail <- DTLoc[1,]
nbFailCpt = 0;#DTLoc[1,perdant]
DTNbFail <- cbind(DTNbFail,data.table(nbFail=nbFailCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 0){
nbFailCpt = nbFailCpt+1;
}else{
nbFailCpt = 0;
}
DTNbFail <- rbind(DTNbFail,cbind(DTLoc[i,],data.table(nbFail=nbFailCpt)))
}
DTLoc <- DTNbFail
#nombre de wins consecutifs
DTNbWin <- DTLoc[1,]
nbWinCpt = 0;#DTLoc[1,gagnant]
DTNbWin <- cbind(DTNbWin,data.table(nbWin=nbWinCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 1){
nbWinCpt = nbWinCpt+1;
}else{
nbWinCpt = 0;
}
DTNbWin <- rbind(DTNbWin,cbind(DTLoc[i,],data.table(nbWin=nbWinCpt)))
}
DTLoc <- DTNbWin
#On calcule une somme lissée des echecs et succes
DTResLisse <- DTLoc[1,]
resLisseCur <- 0
DTResLisse <- cbind(DTResLisse,data.table(resLisse=resLisseCur))
alpha <- 0.7;
for(i in 2:nrow(DTLoc)){
res <- DTLoc[i-1,gagnant]*2-1
resLisseCur <- alpha * resLisseCur + res;
DTResLisse <- rbind(DTResLisse,cbind(DTLoc[i,],data.table(resLisse=resLisseCur)))
}
DTLoc <- DTResLisse
return (DTLoc)
}
removeHeadTail <- function(DTLoc,nb,bHead=TRUE){
#garder que les 20 derniers tours de chaque personne
DTLoc <- as.data.table(DTLoc)
setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
if(bHead)
DTLoc <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
else
DTLoc <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
return(DTLoc)
}
lienErreurEvalDiffResLisse <- function(DTLoc){
print("Anova res lisse");
fit <- aov(erreurdiff ~ resLisse, data=DTLoc);
print(summary(fit));
print("Regression linéaire");
fitl <- glm(DTLoc$erreurdiff ~ DTLoc$resLisse);
#abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
print(summary(fitl));
return(fitl);
}
lienErreurEvalDiffFailsRepetes <- function(DTLoc,fails = TRUE,titre="title"){
if(fails){
plot(x=DTLoc$nbFail, y=DTLoc$erreurdiff, main=titre, xlab="Nombre d'échecs consécutifs (nbFail)", ylab="Erreur d'estimation de la difficulté")
TMP <- DTLoc[, .(meanDiffEstimated=mean(erreurdiff)),by=nbFail]
TMP2 <- DTLoc[, .(varUpDiffEstimated=mean(erreurdiff)+2*sd(erreurdiff)),by=nbFail]
TMP3 <- DTLoc[, .(varDownDiffEstimated=mean(erreurdiff)-2*sd(erreurdiff)),by=nbFail]
setkey(TMP,nbFail)
setkey(TMP2,nbFail)
setkey(TMP3,nbFail)
points(y=TMP$meanDiffEstimated, x=TMP$nbFail, col="red", type="o")
points(y=TMP2$varUpDiffEstimated, x=TMP2$nbFail, col="blue", type="o")
points(y=TMP3$varDownDiffEstimated, x=TMP3$nbFail, col="blue", type="o")
print("Anova")
fit <- aov(erreurdiff ~ nbFail, data=DTLoc)
print(summary(fit))
print("Regression linéaire")
fitl <- glm(DTLoc$erreurdiff ~ DTLoc$nbFail)
abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
print(summary(fitl))
}
else{
plot(x=DTLoc$nbWin, y=DTLoc$erreurdiff, main=titre, xlab="Nombre de succès consécutifs (nbWin)", ylab="Erreur d'estimation de la difficulté")
TMP <- DTLoc[, .(meanDiffEstimated=mean(erreurdiff)),by=nbWin]
TMP2 <- DTLoc[, .(varUpDiffEstimated=mean(erreurdiff)+2*sd(erreurdiff)),by=nbWin]
TMP3 <- DTLoc[, .(varDownDiffEstimated=mean(erreurdiff)-2*sd(erreurdiff)),by=nbWin]
setkey(TMP,nbWin)
setkey(TMP2,nbWin)
setkey(TMP3,nbWin)
points(y=TMP$meanDiffEstimated, x=TMP$nbWin, col="red", type="o")
points(y=TMP2$varUpDiffEstimated, x=TMP2$nbWin, col="blue", type="o")
points(y=TMP3$varDownDiffEstimated, x=TMP3$nbWin, col="blue", type="o")
#ggplot(data=DTLoc, aes(factor(DTLoc$nbWin),erreurdiff)) + geom_boxplot()
print("Anova")
fit <- aov(erreurdiff ~ nbWin, data=DTLoc)
print(summary(fit))
fitl <- glm(DTLoc$erreurdiff ~ DTLoc$nbWin)
abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
print("Regression linéaire")
print(summary(fitl))
}
return(fitl)
}
#plot les courbes de diff
plotCurves <- function (numStep,diffSubj,diffObj,confiance){
#print(diffSubj);
df <- data.frame(ns=numStep,do=diffObj,ds=diffSubj,c=confiance)
pl <- ggplot(df,aes(x=ns,y=diffObj));
pl <- pl + geom_point(size=1);
pl <- pl + geom_line(size=0.5,colour="#992299");
pl <- pl + geom_line(aes(x=ns,y=diffSubj),size=0.5,colour="#992222");
pl <- pl + geom_line(aes(x=ns,y=confiance),size=0.5,colour="#229922");
#pl <- pl + coord_fixed(ratio = 20);
print(pl)
}
#---------------------------------- traitement
#Prepa plot
#attach(mtcars)
#par(mfrow=c(5,3))
#on recup les données
csv.data <- read.csv(file,header=TRUE,sep=";")
#difficulte logique
DTL <- csv.data[which(csv.data$nom_du_jeu=="Logique2"),]
DTL <- as.data.table(DTL)
DTL <- addVariables(DTL,drawLogit,titre="Jeu de déduction (difficulté logique)")
#difficulte logique
DTL <- csv.data[which(csv.data$nom_du_jeu=="Logique2"),]
DTL <- as.data.table(DTL)
DTL <- addVariables(DTL,drawLogit,titre="Jeu de déduction (difficulté logique)")
fit <- lienErreurEvalDiffFailsRepetes(DTL,TRUE,"Jeu de déduction (difficulté logique)")
#creation de la table totale
DT <- data.table()
if(useLogique) DT <- rbind(DT,DTL)
if(useMotrice) DT <- rbind(DT,DTM)
if(useSensorielle) DT <- rbind(DT,DTS)
#supprimer le debut ou la fin
if(removeTenFirst)
DT <- removeHeadTail(DT,10);
#lien erreur d'eval diff (exces confiance ?) et fails ou succes répétés
fit <- lienErreurEvalDiffFailsRepetes(DT,TRUE,"Tous les jeux")
fit <- lienErreurEvalDiffFailsRepetes(DT,FALSE,"Tous les jeux")
fit <- lienErreurEvalDiffResLisse(DT)
#difficulte sensorielle
DTS <- csv.data[which(csv.data$nom_du_jeu=="Sensoriel"),]
DTS <- as.data.table(DTS)
DTS <- addVariables(DTS,drawLogit,titre="Jeu de perception visuelle (difficulté sensorielle)")
plot(fit)
DTS <- as.data.table(DTS)
DTS <- addVariables(DTS,drawLogit,titre="Jeu de perception visuelle (difficulté sensorielle)")
void <- DTL[,{plotCurves(action_de_jeu,evalDiff,estDiff,resLisse);NULL},by=.(IDjoueur)]
#difficulte motrice
DTM <- csv.data[which(csv.data$nom_du_jeu=="Motrice"),]
DTM <- as.data.table(DTM)
DTM$difficulty <-  (DTM$difficulty)/ abs(max(DTM$difficulty)) #normalisation difficulte
DTM <- addVariables(DTM,drawLogit,titre="Jeu d'adresse (difficulté motrice)")
fit <- lienErreurEvalDiffResLisse(DTL)
plot(fit)
DTM$difficulty <-  (DTM$difficulty)/ abs(max(DTM$difficulty)) #normalisation difficulte
DTM <- addVariables(DTM,drawLogit,titre="Jeu d'adresse (difficulté motrice)")
plot(fit)
if(useMotrice) DT <- rbind(DT,DTM)
if(useSensorielle) DT <- rbind(DT,DTS)
#supprimer le debut ou la fin
if(removeTenFirst)
DT <- removeHeadTail(DT,10);
#lien erreur d'eval diff (exces confiance ?) et fails ou succes répétés
fit <- lienErreurEvalDiffFailsRepetes(DT,TRUE,"Tous les jeux")
fit <- lienErreurEvalDiffFailsRepetes(DT,FALSE,"Tous les jeux")
fit <- lienErreurEvalDiffResLisse(DT)
plot(fit)
void <- DTL[,{plotCurves(action_de_jeu,evalDiff,estDiff,resLisse);NULL},by=.(IDjoueur)]
fit <- lienErreurEvalDiffFailsRepetes(DTM,TRUE,"Jeu d'adresse (difficulté motrice)")
plot(fit)
void <- DTM[,{plotCurves(action_de_jeu,evalDiff,estDiff,resLisse);NULL},by=.(IDjoueur)]
fit <- lienErreurEvalDiffFailsRepetes(DTS,TRUE,"Jeu de perception visuelle (difficulté sensorielle)")
plot(fit)
void <- DTS[,{plotCurves(action_de_jeu,evalDiff,estDiff,resLisse);NULL},by=.(IDjoueur)]
View(DTS)
View(DTLoc)
p <- ggplot(DTLoc, aes(factor(cyl), mpg))
p + geom_boxplot()
print(p)
p <- ggplot(DTLoc, aes(factor(miseNorm), IDJoueur))
p + geom_boxplot()
p <- ggplot(DTLoc, aes(factor(miseNorm), IDjoueur))
p + geom_boxplot()
print(p)
p <- ggplot(DTLoc, aes(miseNorm))
p + geom_boxplot()
print(p)
p <- ggplot(DTLoc, aes(miseNorm))
p + geom_boxplot()
print(p)
p <- ggplot(DTLoc, aes(factor(miseNorm)))
p + geom_boxplot()
print(p)
p <- ggplot(DTLoc, aes(IDjoueur,miseNorm))
p + geom_boxplot()
DTMeans = DTLoc[,.(sdMise=sd(miseNorm)),by=IDjoueur]
View(DTResLisse)
View(DTMeans)
p <- ggplot(DTMeans, aes(miseNorm))
p <- ggplot(DTMeans, aes(miseNorm))
p + geom_boxplot()
DTMeans = DTLoc[,.(sdMise=sd(miseNorm)),by=IDjoueur]
p <- ggplot(DTMeans, aes(sdMise))
p + geom_boxplot()
print(p)
p <- ggplot(DTMeans, aes(IDjoueur,sdMise))
p + geom_boxplot()
print(p)
DTMeans = DTLoc[,.(id=1,sdMise=sd(miseNorm)),by=IDjoueur]
p <- ggplot(DTMeans, aes(id,sdMise))
p + geom_boxplot()
file = "./log_thomas_XPFINALES.txt"
csv.data <- read.csv(file,header=TRUE,sep=";")
DT <- as.data.table(csv.data)
DTM <- csv.data[which(csv.data$nom_du_jeu=="Motrice"),]
DTM <- as.data.table(DTM)
DTM$difficulty <-  (DTM$difficulty)/ abs(max(DTM$difficulty)) #normalisation difficulte
DTLoc <- DTM;
trace=FALSE;
titre = "titre";
#echec au lieu de succes pour diff c'est mieux
DTLoc$perdant <- 1-DTLoc$gagnant;
#normalisation de la mise
DTLoc$miseNorm <- DTLoc$mise / 7;
#difficulte évaluée par le joueur
DTLoc$evalDiff <- 1 - DTLoc$miseNorm;
#On ajoute une colonne de la difficulte estimee, a partir d'un
#logit de la difficulte supposée sur l'échec constaté
mylogit <- glm(perdant ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
sample = data.frame(difficulty=DTLoc$difficulty);
DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response");
#erreur d'estimation de la difficulte par le joueur (exces de confiance ?)
DTLoc$erreurdiff <- DTLoc$evalDiff - DTLoc$estDiff;
#nombre de fail consecutifs
DTNbFail <- DTLoc[1,]
nbFailCpt = 0;#DTLoc[1,perdant]
DTNbFail <- cbind(DTNbFail,data.table(nbFail=nbFailCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 0){
nbFailCpt = nbFailCpt+1;
}else{
nbFailCpt = 0;
}
DTNbFail <- rbind(DTNbFail,cbind(DTLoc[i,],data.table(nbFail=nbFailCpt)))
}
DTLoc <- DTNbFail
#nombre de wins consecutifs
DTNbWin <- DTLoc[1,]
nbWinCpt = 0;#DTLoc[1,gagnant]
DTNbWin <- cbind(DTNbWin,data.table(nbWin=nbWinCpt))
for(i in 2:nrow(DTLoc)){
if(DTLoc[i-1,gagnant] == 1){
nbWinCpt = nbWinCpt+1;
}else{
nbWinCpt = 0;
}
DTNbWin <- rbind(DTNbWin,cbind(DTLoc[i,],data.table(nbWin=nbWinCpt)))
}
DTLoc <- DTNbWin
#On calcule une somme lissée des echecs et succes
DTResLisse <- DTLoc[1,];
resLisseCur <- 0;
DTResLisse <- cbind(DTResLisse,data.table(resLisse=resLisseCur));
alpha <- 0.5;
for(i in 2:nrow(DTLoc)){
res <- (DTLoc[i-1,gagnant]*2)-1;
resLisseCur <- alpha * resLisseCur + res;
DTResLisse <- rbind(DTResLisse,cbind(DTLoc[i,],data.table(resLisse=resLisseCur)));
}
DTLoc <- DTResLisse
DTMeans = DTLoc[,.(id=1,sdMise=sd(miseNorm)),by=IDjoueur]
p <- ggplot(DTMeans, aes(id,sdMise))
p + geom_boxplot()
print(p)
print("Anova res lisse")
fit <- aov(erreurdiff ~ resLisse, data=DTLoc)
sum_fit1 = unlist(summary(fit))
print("Anova nbWin")
fit <- aov(erreurdiff ~ nbWin, data=DTLoc)
sum_fit2 = unlist(summary(fit))
print("Anova nbFail")
fit <- aov(erreurdiff ~ nbFail, data=DTLoc)
sum_fit3 = unlist(summary(fit))
#print(summary(fit))
print(sum_fit1["Pr(>F)1"]);
print(sum_fit2["Pr(>F)1"]);
print(sum_fit3["Pr(>F)1"]);
print("Regression linéaire")
#fitl <- glm(DTLoc$erreurdiff ~ DTLoc$resLisse)
#abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
#print(summary(fitl))
#plot(fitl)
DTMeans = DTLoc[,.(id=1,sdMise=sd(miseNorm)),by=IDjoueur]
p <- ggplot(DTMeans, aes(id,sdMise))
p + geom_boxplot()
p + geom_boxplot() + geom_point(shape=1)
p + geom_boxplot() + geom_point(shape=1) + geom_jitter()
DTMeans = DTLoc[,.(id=1,sdMise=sd(miseNorm)),by=IDjoueur]
p <- ggplot(DTMeans, aes(id,sdMise))
p + geom_boxplot() + geom_point(shape=1) + geom_jitter()
print(p)
p + geom_boxplot() + geom_point(shape=1) + geom_jitter()
p + geom_boxplot() + geom_point(shape=1)
outlier <- boxplot.stats(DTMeans$sdMise)$out
outlier
boxplot.stats(DTMeans$sdMise)
DTMeans = DTLoc[,.(id="Moteur",sdMise=sd(miseNorm)),by=IDjoueur]
p <- ggplot(DTMeans, aes(id,sdMise))
p + geom_boxplot() + geom_point(shape=1)
print(p)
p <- p + geom_boxplot() + geom_point(shape=1)
print(p)
DTMeans = data.table();
DTMeans = cbind(DTMeans,DTLoc[,.(id="Moteur",sdMise=sd(miseNorm)),by=IDjoueur])
DTMeans = DTLoc[,.(id="Moteur",sdMise=sd(miseNorm)),by=IDjoueur]
DTMeans = rbind(DTMeans,DTLoc[,.(id="Senso",sdMise=sd(miseNorm)),by=IDjoueur])
p <- ggplot(DTMeans, aes(id,sdMise))
p <- p + geom_boxplot() + geom_point(shape=1)
print(p)
DTDesc = data.table();
DTDesc = DTM[,.(id="Moteur",sdMise=sd(miseNorm)),by=IDjoueur]
DTDesc = rbind(DTDesc,DTS[,.(id="Senso",sdMise=sd(miseNorm)),by=IDjoueur])
DTDesc = rbind(DTDesc,DTL[,.(id="Logique",sdMise=sd(miseNorm)),by=IDjoueur])
p <- ggplot(DTDesc, aes(id,sdMise))
p <- p + geom_boxplot() + geom_point(shape=1)
print(p)
