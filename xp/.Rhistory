test = numeric(10)
confMin = numeric(10)
confMax = numeric(10)
for(i in 1:10){
diffic = round(i/10,1)
print(diffic)
#res[i] = table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["1"] /
#            table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["0"]
#res[i] = mean(DTLoc[round(estDiff,1)==diffic]$miseNorm)
data = DTLoc[round(estDiff,1)==diffic]$miseNorm;
if(length(data) > 1){
testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T)
test[i] = echoPValue(testWilly$p.value)
res[i] = testWilly$estimate
confMin[i] = testWilly$conf.int[1]
confMax[i] = testWilly$conf.int[2]
nb[i] = length(data)
diff[i] = diffic
}else{
diff[i] = NA;
res[i] = NA;
}
}
i=1
diffic = round(i/10,1)
print(diffic)
data = DTLoc[round(estDiff,1)==diffic]$miseNorm;
data
if(length(data) > 1){
testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T)
test[i] = echoPValue(testWilly$p.value)
res[i] = testWilly$estimate
confMin[i] = testWilly$conf.int[1]
confMax[i] = testWilly$conf.int[2]
nb[i] = length(data)
diff[i] = diffic
}else{
diff[i] = NA;
res[i] = NA;
}
testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T)
testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T)
test[i] = echoPValue(testWilly$p.value)
testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T)
for(i in 1:10){
diffic = round(i/10,1)
print(diffic)
#res[i] = table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["1"] /
#            table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["0"]
#res[i] = mean(DTLoc[round(estDiff,1)==diffic]$miseNorm)
data = DTLoc[round(estDiff,1)==diffic]$miseNorm;
diff[i] = NA;
res[i] = NA;
if(length(data) > 1){
try{
res = numeric(10)
nb = numeric(10)
diff = numeric(10)
test = numeric(10)
confMin = numeric(10)
confMax = numeric(10)
for(i in 1:10){
diffic = round(i/10,1)
print(diffic)
#res[i] = table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["1"] /
#            table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["0"]
#res[i] = mean(DTLoc[round(estDiff,1)==diffic]$miseNorm)
data = DTLoc[round(estDiff,1)==diffic]$miseNorm;
diff[i] = NA
res[i] = NA
if(length(data) > 1){
result = try(testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T))
if (class(result) != "try-error"){
test[i] = echoPValue(testWilly$p.value)
res[i] = testWilly$estimate
confMin[i] = testWilly$conf.int[1]
confMax[i] = testWilly$conf.int[2]
nb[i] = length(data)
diff[i] = diffic
}
}
}
res = numeric(10)
nb = numeric(10)
diff = numeric(10)
test = numeric(10)
confMin = numeric(10)
confMax = numeric(10)
for(i in 1:10){
diffic = round(i/10,1)
print(diffic)
#res[i] = table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["1"] /
#            table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["0"]
#res[i] = mean(DTLoc[round(estDiff,1)==diffic]$miseNorm)
data = DTLoc[round(estDiff,1)==diffic]$miseNorm;
diff[i] = NA
res[i] = NA
if(length(data) > 1){
result = try(wilcox.test(data,mu = 1-diffic,conf.int=T))
if (class(result) != "try-error"){
testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T)
test[i] = echoPValue(testWilly$p.value)
res[i] = testWilly$estimate
confMin[i] = testWilly$conf.int[1]
confMax[i] = testWilly$conf.int[2]
nb[i] = length(data)
diff[i] = diffic
}
}
}
#---------------------------------- fonctions
echoPValue <- function(pv){
pv = signif(pv,digits=2)
if(pv<0.001) {
return(paste(pv,"***"));
}else if(pv<0.01){
return(paste(pv,"**"));
}else  if(pv<0.05){
return(paste(pv,"*"));
}else if(pv<0.1){
return(paste(pv,"."));
}else{
return(paste(pv,":("));
}
return("");
}
addVariables <- function(DTLoc,trace = FALSE,titre="noTitle"){
#echec au lieu de succes pour diff c'est mieux
DTLoc$perdant <- 1-DTLoc$gagnant;
#This is FAIL: si on vire les mises, le modèle est parfait
#DTLoc$mise = 0;
#normalisation de la mise
DTLoc$miseNorm <- DTLoc$mise / 7;
#difficulte évaluée par le joueur
DTLoc$evalDiff <- 1 - DTLoc$miseNorm;
#difficulte evaluee par le joueur : logit approach
DTLoc[,miseBin := 0][mise >= 4, miseBin := 1]
DTLoc[,evalDiffBin := 1][mise >= 4, evalDiffBin := 0]
# plot(x=diff,y=res,xlim=c(0,1),ylim=c(0,1))
# abline(1,-1)
# for(i in 1:10){
#   lines(c(diff[i],diff[i]),c(confMin[i],confMax[i]))
# }
# #bidouille : On fait des groupes de joueurs mais en fait on s'en fout
# diffLmer <- lmer(perdant ~ difficulty + (1 | IDjoueur), data=DTLoc);
# #niveau du joueur = - l'effet sur la difficulté
# niveauJoueurLmer = - ranef(diffLmer)$IDjoueur;
# #colnames(niveauJoueurLmer) <- c("niveau")
# DTLevel = data.table(IDjoueur=rownames(niveauJoueurLmer),niveau=niveauJoueurLmer);
# setnames(DTLevel,"niveau.(Intercept)","niveau")
# setkey(DTLoc,IDjoueur)
# setkey(DTLevel,IDjoueur)
# DTLoc <- DTLoc[DTLevel]
# DTLoc <- DTLoc[order(niveau)]
#
# #KMEANS
#
# #groups = kmeans(DTLoc$niveau, 6)$cluster
# #   wss <- numeric(13)
# #   for (i in 2:15) wss[i] <- sum(kmeans(DTLoc$niveau, i)$withinss)
# #   plot(1:15, wss, type="b", xlab="Number of Clusters",  ylab="Within groups sum of squares")
#
# #hierarchical clustering
# fit = hclust(dist(DTLoc$niveau), "ward.D2")
# #plot(fit,hang=-1)
# groups <- cutree(fit, k=4)
# DTLoc$groupLevel = groups;
#
# #cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# ggplot(DTLoc, aes(niveau, reorder(IDjoueur, niveau),color=factor(DTLoc$groupLevel)))+
#   geom_point(alpha = 0.4, size = 3.5)
#   #scale_color_manual(values=cbbPalette)
#   hist(DTLoc[round(estDiff,1)==0.4]$miseNorm)
#   hist(DTLoc[difficulty==0.4]$miseNorm)
#
# ggplot(data = DTLoc, aes(x=estDiff, y=evalDiff)) + geom_boxplot(aes(group=round(estDiff,1)))
#
# ggplot(data = DTLoc[groupLevel==3], aes(x=estDiff, y=evalDiff)) + geom_boxplot(aes(group=round(estDiff,1)))
# ggplot(data = DTLoc[groupLevel==3], aes(x=difficulty, y=evalDiff)) + geom_boxplot(aes(group=difficulty))
#Difficultée évaluée par le joueur avec un logit sur la mise mais bon
# mylogit <- glm(evalDiff ~ difficulty, data = DTLoc)
#
# mylogit <- glm(evalDiffBin ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
# print(summary(mylogit));
# sample = data.frame(difficulty=DTLoc$difficulty);
# DTLoc$evalDiff =  predict(mylogit, newdata = sample, type = "response");
#
# if(trace){
#   sample = data.frame(difficulty=seq(0, 1, 0.05))
#   newres = predict(mylogit, newdata = sample, type = "response")
#   plot(DTLoc$difficulty, DTLoc$evalDiffBin, main=titre, xlab="Difficulté hypothétique",  ylab="Difficulté estimée (mise)",  col=rgb(0,100,0,100,maxColorValue=255))
#   points(data.frame(sample,newres), type="o")
# }
#On ajoute une colonne de la difficulte estimee, a partir d'un
#logit de la difficulte supposée sur l'échec constaté
mylogit <- glm(perdant ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
if(effetMixtes == TRUE){
#mylogit <- lmer(perdant ~ difficulty + (1 | IDjoueur), data=DTLoc);
mylogit <- glmer(perdant ~ difficulty + (1 | IDjoueur), data=DTLoc,family = "binomial"(link = "logit"));
sample = data.frame(difficulty=DTLoc$difficulty, IDjoueur=DTLoc$IDjoueur);
DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response");
}else{
sample = data.frame(difficulty=DTLoc$difficulty);
DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response");
}
print(summary(mylogit));
#sjp.glmer(mylogit, sort = "(Intercept)")
niveauJoueurLmer = -ranef(mylogit)$IDjoueur;
DTLevel = data.table(IDjoueur=rownames(niveauJoueurLmer),niveau=niveauJoueurLmer);
setnames(DTLevel,"niveau.(Intercept)","niveau")
DTLevel = DTLevel[order(abs(niveau))];
joueurMed = DTLevel[1]$IDjoueur
DTLevel = DTLevel[order(niveau)];
joueurMin = DTLevel[1]$IDjoueur
joueurMax = DTLevel[nrow(DTLevel)]$IDjoueur
for(i in 1:nrow(DTLevel)){
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=DTLevel[i]$IDjoueur)
newres = predict(mylogit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = DTLevel[i]$IDjoueur, estDiff = newres)
if(i==1)
p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 0.2) + xlim(0,1) + ylim(0,1)
else
p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 0.2,size=1.2)
}
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed)
newres = predict(mylogit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMed, estDiff = newres)
p = p + geom_path(x=DT$difficulty,y=DT$estDiff,color="blue",size=1.3)
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMin)
newres = predict(mylogit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMin, estDiff = newres)
p = p + geom_path(x=DT$difficulty,y=DT$estDiff,color="red",size=1.3)
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMax)
newres = predict(mylogit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMax, estDiff = newres)
p = p + geom_path(x=DT$difficulty,y=DT$estDiff,color="green",size=1.3)
print(p)
#GUIGUI TODO : si lmer, tracer la courbe moyenne, et +- 1  ecart type
if(trace && effetMixtes == FALSE){
sample = data.frame(difficulty=seq(0, 1, 0.05))
newres = predict(mylogit, newdata = sample, type = "response")
plot(DTLoc$difficulty, DTLoc$perdant, main=titre, xlab="Difficulté hypothétique",  ylab="Difficulté objective (estimée)",  col=rgb(0,100,0,100,maxColorValue=255))
points(data.frame(sample,newres), type="o")
}
#difficulté équilibrée ? normalement oui
p = ggplot(DTLoc,aes(x=estDiff)) + geom_histogram(col="black", fill="white")+xlim(0,1)
print(p)
# print(hist(DTLoc$estDiff,breaks=30)
# abline(v=mean(DTLoc$estDiff),col = "blue", lwd = 2))
# print(p + p2)
#
#Lien entre mise normalisée et difficultée estimée (hard / easy effect)
res = numeric(10)
nb = numeric(10)
diff = numeric(10)
test = numeric(10)
confMin = numeric(10)
confMax = numeric(10)
for(i in 1:10){
diffic = round(i/10,1)
print(diffic)
#res[i] = table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["1"] /
#            table(DTLoc[round(estDiff,1)==round(i/10,1)]$miseBin)["0"]
#res[i] = mean(DTLoc[round(estDiff,1)==diffic]$miseNorm)
data = DTLoc[round(estDiff,1)==diffic]$miseNorm;
diff[i] = NA
res[i] = NA
if(length(data) > 1){
result = try(wilcox.test(data,mu = 1-diffic,conf.int=T))
if (class(result) != "try-error"){
testWilly = wilcox.test(data,mu = 1-diffic,conf.int=T)
test[i] = echoPValue(testWilly$p.value)
res[i] = testWilly$estimate
confMin[i] = testWilly$conf.int[1]
confMax[i] = testWilly$conf.int[2]
nb[i] = length(data)
diff[i] = diffic
}
}
}
#plot(diff,res,log="y")
print(data.table(estDiff=diff,pval=test))
DT = data.table(difficulty=diff,miseNorm=res)
p = ggplot(DT, aes(difficulty,miseNorm)) +
geom_point(alpha = 0.4, size = 3.5) +
xlim(0,1)+
ylim(0,1)+
geom_errorbar(aes(ymin=confMin, ymax=confMax), width=.01,color="red")  +
geom_abline(intercept = 1, slope = -1, color="blue")
print(p)
#erreur d'estimation de la difficulte par le joueur (exces de confiance ?)
DTLoc$erreurDiffConfiance <- DTLoc$estDiff - DTLoc$evalDiff;
#nombre de fails
temps <- proc.time()[1];
gagnant = DTLoc$gagnant; #sous table, pour gagner du temps au lookup
id = DTLoc$IDjoueur; #sous table, pour gagner du temps au lookup
nbFailCpt = 0;
lastID <- id[1];
res <- numeric(nrow(DTLoc))
res[1] = 0;
resLastFail <- numeric(nrow(DTLoc))
resLastFail[1] = 0;
for(i in 2:nrow(DTLoc)){
if(id[i] != lastID){
nbFailCpt = 0;
resLastFail[i] = 0;
}else{
if(gagnant[i-1] == 0){
nbFailCpt = nbFailCpt+1;
resLastFail[i] = 1;
}else{
nbFailCpt = 0;
resLastFail[i] = 0;
}
}
lastID = id[i-1];
#if(nbFailCpt > 5)
#nbFailCpt = 5
res[i] <- nbFailCpt;
}
DTLoc$nbFail = res;
DTLoc$lastFail = res;
print(paste("Fails:",toString(proc.time()[1]-temps)))
temps <- proc.time()[1];
nbWinCpt = 0;
lastWin = 0;
lastID <- id[1];
res <- numeric(nrow(DTLoc))
res[1] = 0;
resLastWin <- numeric(nrow(DTLoc))
resLastWin[1] = 0;
for(i in 2:nrow(DTLoc)){
if(id[i] != lastID){
nbWinCpt = 0;
resLastWin[i] = 0;
}else{
if(gagnant[i-1] == 1){
nbWinCpt = nbWinCpt+1;
resLastWin[i] = 1;
}else{
nbWinCpt = 0;
resLastWin[i] = 0;
}
}
lastID = id[i];
#if(nbWinCpt > 5)
# nbWinCpt = 5
res[i] <- nbWinCpt;
}
DTLoc$nbWin = res;
DTLoc$lastWin = resLastWin;
print(paste("Wins:",toString(proc.time()[1]-temps)))
temps <- proc.time()[1];
#On calcule une somme lissée des echecs et succes
resLisseCur = 0;
lastID <- id[1];
res <- numeric(nrow(DTLoc))
res[1] = 0;
diffObj = DTLoc$estDiff;
alpha <- 0.9;
for(i in 2:nrow(DTLoc)){
if(id[i] != lastID){
resLisseCur = 0;
}else{
#confiance <- gagnant[i-1]*2-1
if(gagnant[i-1]){
confiance = diffObj[i-1];
}else{
confiance = -(1 - diffObj[i-1]);
}
resLisseCur <- alpha * resLisseCur + confiance;
}
lastID = id[i];
res[i] = resLisseCur;
}
DTLoc$resLisseBase = res;
DTLoc$resLisse = exp(DTLoc$resLisseBase) / (1+exp(DTLoc$resLisseBase));
print(paste("Lissee:",toString(proc.time()[1]-temps)))
temps <- proc.time()[1];
#delta de mise cumulé pour trouvé les mecs qui font du 1/7/1/7/1/7
cumulDeltaMise = 0;
mise = DTLoc$mise;
lastID <- id[1];
res <- numeric(nrow(DTLoc))
res[1] = 0;
for(i in 2:nrow(DTLoc)){
if(id[i] != lastID){
cumulDeltaMise = 0;
}else{
cumulDeltaMise = cumulDeltaMise + abs(mise[i] - mise[i-1]);
}
lastID = id[i];
res[i] = cumulDeltaMise;
}
DTLoc$cumulDeltaMise = res;
return (DTLoc)
}
removeHeadTail <- function(DTLoc,nb,bHead=TRUE){
#garder que les 20 derniers tours de chaque personne
DTLoc <- as.data.table(DTLoc)
setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
if(bHead)
DTLoc <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
else
DTLoc <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
return(DTLoc)
}
lienErreurEvalDiffResLisse <- function(DTLoc,titre="title"){
plot(x=DTLoc$resLisse, y=DTLoc$erreurDiffConfiance, main=titre, xlab="Indice de confiance lissé", ylab="Erreur d'estimation de la difficulté")
# TMP <- DTLoc[, .(meanDiffEstimated=mean(erreurDiffConfiance)),by=nbFail]
# TMP2 <- DTLoc[, .(varUpDiffEstimated=mean(erreurDiffConfiance)+2*sd(erreurDiffConfiance)),by=nbFail]
# TMP3 <- DTLoc[, .(varDownDiffEstimated=mean(erreurDiffConfiance)-2*sd(erreurDiffConfiance)),by=nbFail]
# setkey(TMP,nbFail)
# setkey(TMP2,nbFail)
# setkey(TMP3,nbFail)
# points(y=TMP$meanDiffEstimated, x=TMP$nbFail, col="red", type="o")
# points(y=TMP2$varUpDiffEstimated, x=TMP2$nbFail, col="blue", type="o")
# points(y=TMP3$varDownDiffEstimated, x=TMP3$nbFail, col="blue", type="o")
print("Anova res lisse");
fit <- aov(erreurDiffConfiance ~ resLisse, data=DTLoc);
if(echoModels)
print(summary(fit));
print("Regression linéaire");
fitl <- glm(DTLoc$erreurDiffConfiance ~ DTLoc$resLisse);
abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
if(echoModels)
print(summary(fitl));
return(fit);
}
lienErreurEvalDiffFailsRepetes <- function(DTLoc,fails = TRUE,titre="title"){
if(fails){
plot(x=DTLoc$nbFail, y=DTLoc$erreurDiffConfiance, main=titre, xlab="Nombre d'échecs consécutifs (nbFail)", ylab="Erreur d'estimation de la difficulté")
TMP <- DTLoc[, .(meanDiffEstimated=mean(erreurDiffConfiance)),by=nbFail]
TMP2 <- DTLoc[, .(varUpDiffEstimated=mean(erreurDiffConfiance)+2*sd(erreurDiffConfiance)),by=nbFail]
TMP3 <- DTLoc[, .(varDownDiffEstimated=mean(erreurDiffConfiance)-2*sd(erreurDiffConfiance)),by=nbFail]
setkey(TMP,nbFail)
setkey(TMP2,nbFail)
setkey(TMP3,nbFail)
points(y=TMP$meanDiffEstimated, x=TMP$nbFail, col="red", type="o")
points(y=TMP2$varUpDiffEstimated, x=TMP2$nbFail, col="blue", type="o")
points(y=TMP3$varDownDiffEstimated, x=TMP3$nbFail, col="blue", type="o")
print("Anova")
fit <- aov(erreurDiffConfiance ~ nbFail, data=DTLoc)
if(echoModels)
print(summary(fit))
print("Regression linéaire")
fitl <- glm(DTLoc$erreurDiffConfiance ~ DTLoc$nbFail)
abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="green")
if(echoModels)
print(summary(fitl))
}
else{
plot(x=DTLoc$nbWin, y=DTLoc$erreurDiffConfiance, main=titre, xlab="Nombre de succès consécutifs (nbWin)", ylab="Erreur d'estimation de la difficulté")
TMP <- DTLoc[, .(meanDiffEstimated=mean(erreurDiffConfiance)),by=nbWin]
TMP2 <- DTLoc[, .(varUpDiffEstimated=mean(erreurDiffConfiance)+2*sd(erreurDiffConfiance)),by=nbWin]
TMP3 <- DTLoc[, .(varDownDiffEstimated=mean(erreurDiffConfiance)-2*sd(erreurDiffConfiance)),by=nbWin]
setkey(TMP,nbWin)
setkey(TMP2,nbWin)
setkey(TMP3,nbWin)
points(y=TMP$meanDiffEstimated, x=TMP$nbWin, col="red", type="o")
points(y=TMP2$varUpDiffEstimated, x=TMP2$nbWin, col="blue", type="o")
points(y=TMP3$varDownDiffEstimated, x=TMP3$nbWin, col="blue", type="o")
#ggplot(data=DTLoc, aes(factor(DTLoc$nbWin),erreurDiffConfiance)) + geom_boxplot()
print("Anova")
fit <- aov(erreurDiffConfiance ~ nbWin, data=DTLoc)
if(echoModels)
print(summary(fit))
fitl <- glm(DTLoc$erreurDiffConfiance ~ DTLoc$nbWin)
abline(a =fitl$coefficients[1], b=fitl$coefficients[2], col="purple")
print("Regression linéaire")
if(echoModels)
print(summary(fitl))
}
return(fit)
}
#plot les courbes de diff
plotCurves <- function (numStep,difficulty,diffSubj,diffObj,confiance,id,nbWin,nbFail,error,mise,title){
df <- data.frame(ns=numStep,do=diffObj,ds=diffSubj,c=confiance)
pl <- ggplot(df,aes(x=ns)) # + ggtitle(id[1]);
pl <- pl + geom_point(aes(y=difficulty,colour="Difficulté du jeu"),size=1);
pl <- pl + geom_line(aes(y=difficulty,colour="Difficulté du jeu"));
pl <- pl + geom_line(aes(y=diffObj,colour="Difficulté Objective"));
pl <- pl + geom_line(aes(y=diffSubj,colour="Difficulté Subjective"));
pl <- pl + geom_line(aes(y=confiance,colour="Confiance"));
pl <- pl + geom_line(aes(y=mise,colour="Mise"));
pl <- pl + ylim(0, 1)
pl <- pl + scale_colour_manual(
values = c("Difficulté du jeu" = "red","Difficulté Objective" = "pink","Difficulté Subjective" = "blue","Confiance" = "green", "Mise" = "black"))
#pl <- pl + geom_line(aes(x=ns,y=nbWin),size=0.5,colour="#555555");
#pl <- pl + geom_line(aes(x=ns,y=nbFail),size=0.5,colour="#000000");
#pl <- pl + coord_fixed(ratio = 20);
pl <- pl  +  ggtitle(title);
print(pl)
}
description <- function(DTLoc){
p <- ggplot(DTLoc, aes(factor(cyl), mpg))
p + geom_boxplot()
print(p)
}
#difficulte motrice
DTM <- dataG[which(dataG$nom_du_jeu=="Motrice"),]
DTM <- as.data.table(DTM)
DTM$difficulty <-  (DTM$difficulty)/ abs(max(DTM$difficulty)) #normalisation difficulte
DTM <- addVariables(DTM,plotLogit,titre="Jeu d'adresse (difficulté motrice)")
#difficulte sensorielle
DTS <- dataG[which(dataG$nom_du_jeu=="Sensoriel"),]
DTS <- as.data.table(DTS)
DTS <- addVariables(DTS,plotLogit,titre="Jeu de perception visuelle (difficulté sensorielle)")
#difficulte logique
DTL <- dataG[which(dataG$nom_du_jeu=="Logique2"),]
DTL <- as.data.table(DTL)
DTL <- addVariables(DTL,plotLogit,titre="Jeu de déduction (difficulté logique)")
