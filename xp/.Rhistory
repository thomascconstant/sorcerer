knit_with_parameters('C:/Users/Thomas Constant/Source/Repos/sorcerer/xp/rapport_fin_xp1.rmd')
#------------------------------------------------------
#                  SETUP : PACKAGES
#------------------------------------------------------
require(xlsx)
require(plyr)
require(data.table)
require(ggplot2)
library(car)
require(lme4)
require(lmerTest)
require(Matrix)
library(usdm)
require(lattice)
require(psychometric)
require(MuMIn)
require(pyramid)
require(sjPlot)
require(arm)
library(MASS)
require(MuMIn)
require(Hmisc)
require(RColorBrewer)
#------------------------------------------------------
#              SETUP : UTILS FUNCTIONS
#------------------------------------------------------
format.pval.stars <- function(pv){
pv = signif(pv,digits=2)
if(pv<0.001) {
return(paste(pv,"***"));
}else if(pv<0.01){
return(paste(pv,"**"));
}else  if(pv<0.05){
return(paste(pv,"*"));
}else if(pv<0.1){
return(paste(pv,"."));
}else{
return(paste(pv,":("));
}
return("unable to format pvalue !!");
}
format.pval.only.stars <- function(pv){
pv = signif(pv,digits=2)
if(pv<0.001) {
return("***");
}else if(pv<0.01){
return("**");
}else  if(pv<0.05){
return("*");
}else if(pv<0.1){
return(".");
}else{
return(":(");
}
return("unable to format pvalue !!");
}
format.coef <- function(coef,p.val){
return(paste(signif(coef,digits=3),format.pval.stars(p.val)))
}
remove.na.cols <- function(DT){
return(as.data.table(DT[,which(unlist(lapply(DT, function(x)!all(is.na(x))))),with=F]))
}
remove.na.rows <- function(DT){
return(as.data.table(DT[rowSums(is.na(DT)) != ncol(DT),]))
}
set.empty.to.na <- function(DT){
return(as.data.table(lapply(DT, function(x){replace(x, x=="",NA)})))
}
remove.head.tail <- function(DT,nb,bHead=TRUE){
DT <- as.data.table(DT)
setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
if(bHead)
DT <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
else
DT <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
return(DT)
}
#Plot la courbe de diff pour un joueur
plot.diff.curve <- function (DT,title){
if(nrow(DT) == 0)
return()
df <- data.frame(time=DT$action_de_jeu,
difficulty=DT$difficulty,
bet=DT$miseNorm)
p <- ggplot(df,aes(x=time))
p <- p + geom_step(aes(y=bet,colour="Bet"))
if(length(DT$obj.diff) > 0)
p <- p + geom_step(aes(y=DT$obj.diff,colour="Objective Difficulty"))
else
p <- p + geom_step(aes(y=difficulty,colour="Difficulty parameter"))
p <- p + ylim(0, 1)
p <- p + scale_colour_manual(
values = c("Difficulty parameter" = "red",
"Objective Difficulty" = "pink",
"Bet" = "blue"))
p <- p  +  ggtitle(title);
print(p)
}
plot.subjective.difficulty.time <- function(DT,selGroup){
print(selGroup)
# Lien entre mise normalisÃ©e et temps (learning effect)
timeNorm.quants = seq(0,1,1/16)#quantile(DT$timeNorm, probs=(seq(0,1,0.05)))
nb.bins = length(timeNorm.quants)-1
subj.diff.med = numeric(nb.bins)
timeNorm.bin = numeric(nb.bins)
timeNorm.bin.cur = 0;
test.pvals = numeric(nb.bins)
conf.min = numeric(nb.bins)
conf.max = numeric(nb.bins)
nb.vals = numeric(nb.bins)
shapes =  numeric(nb.bins)
delta.time.subj = numeric(nb.bins)
hist(DT$timeNorm)
for(i in 1:nb.bins){
#timeNorm.bin.cur = round(i/10,1)
#subj.diff = DT[round(obj.diff,1)==timeNorm.bin.cur]$subj.diff.mise
timeNorm.bin.cur = (timeNorm.quants[i] + timeNorm.quants[i+1])/2.0
#subj.diff = DT[timeNorm > timeNorm.quants[i] & timeNorm<=timeNorm.quants[i+1]]$subj.diff.mise
DTLoc = DT[timeNorm > timeNorm.quants[i] & timeNorm<=timeNorm.quants[i+1]]
if(selGroup != "all")
DTLoc = DTLoc[niveau.group==selGroup]
DTLoc = DTLoc[,.(mise.mean=mean(subj.diff.mise)),by=IDjoueur]
subj.diff = DTLoc$mise.mean
timeNorm.bin[i] = obj.diff.bin.cur
subj.diff.med[i] = NA
test.pvals[i] = NA
conf.min[i] = NA
conf.max[i] = NA
delta.timeNorm[i] = NA
shapes[i] = 16
nb.vals[i] = length(subj.diff)
if(nb.vals[i] > 1){
try.res = try(test.res <- wilcox.test(subj.diff,mu = timeNorm.bin.cur,conf.int=T))
if (class(try.res) != "try-error"){
#print(test.res)
#hist(subj.diff)
test.pvals[i] = format.pval.stars(test.res$p.value)
if(test.res$p.value < 0.05)
shapes[i] = 24
#subj.diff.med[i] = mean(subj.diff)
subj.diff.med[i] = test.res$estimate
conf.min[i] = test.res$conf.int[1]
conf.max[i] = test.res$conf.int[2]
delta.timeNorm[i] = signif(subj.diff.med[i] - timeNorm.bin.cur,digit=2)
}
}
}
#print table of pvalues
print(data.table(timeNorm.bin=timeNorm.bin,delta.time.subj=delta.time.subj,n=nb.vals,pval=test.pvals))
#kernel smooth
subj.diff.smooth <- ksmooth(x=DT$timeNorm,y=DT$subj.diff.mise,bandwidth = 0.2)
DTSmooth = data.table(x=subj.diff.smooth$x,y=subj.diff.smooth$y)
DTPlot = data.table(timeNorm=timeNorm.bin,subj.diff=subj.diff.med, shapes=shapes)
p = ggplot() +
#       geom_line(aes(x=DTPouet$x,y=DTPouet$y))+
geom_point(aes(x=DTPlot$timeNorm,y=DTPlot$subj.diff),alpha = 1, size = 3, shape=DTPlot$shapes) +
xlim(0,1)+
ylim(0,1)+
geom_errorbar(aes(x=DTPlot$timeNorm, ymin=conf.min, ymax=conf.max), width=.01,color="red")  +
geom_abline(intercept = 0, slope = 1, color="blue") +
xlab("Time") + ylab("Subjective Difficulty") + theme(text = element_text(size=15))
print(p)
}
plot.subjective.difficulty.time(DTAll,"all")
