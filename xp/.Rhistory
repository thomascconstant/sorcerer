#  4  : risk neutral
#  5  : slightly risk averse
#  6  : risk averse
#  7  : very risk averse
#  8  : highly risk avers
# 9-10 : max choix sûr
# self efficacy scores
# 0 : not a player so did not answer
# de 10 à 20 : sentiment AE faible
# de 21 à 30 : sentiment AE moyen
# de 31 à 40 : sentiment AE fort
# de 41 à 50 : sentiment AE très fort
#------------------------------------------------------
#                  SETUP : PACKAGES
#------------------------------------------------------
require(xlsx)
require(plyr)
require(data.table)
require(ggplot2)
library(car)
require(lme4)
require(lmerTest)
require(Matrix)
library(usdm)
require(lattice)
require(psychometric)
require(MuMIn)
require(pyramid)
require(sjPlot)
require(arm)
library(MASS)
require(MuMIn)
require(Hmisc)
require(RColorBrewer)
#------------------------------------------------------
#              SETUP : UTILS FUNCTIONS
#------------------------------------------------------
format.pval.stars <- function(pv){
pv = signif(pv,digits=2)
if(pv<0.001) {
return(paste(pv,"***"));
}else if(pv<0.01){
return(paste(pv,"**"));
}else  if(pv<0.05){
return(paste(pv,"*"));
}else if(pv<0.1){
return(paste(pv,"."));
}else{
return(paste(pv,":("));
}
return("unable to format pvalue !!");
}
format.pval.only.stars <- function(pv){
pv = signif(pv,digits=2)
if(pv<0.001) {
return("***");
}else if(pv<0.01){
return("**");
}else  if(pv<0.05){
return("*");
}else if(pv<0.1){
return(".");
}else{
return(":(");
}
return("unable to format pvalue !!");
}
format.coef <- function(coef,p.val){
return(paste(signif(coef,digits=3),format.pval.stars(p.val)))
}
remove.na.cols <- function(DT){
return(as.data.table(DT[,which(unlist(lapply(DT, function(x)!all(is.na(x))))),with=F]))
}
remove.na.rows <- function(DT){
return(as.data.table(DT[rowSums(is.na(DT)) != ncol(DT),]))
}
set.empty.to.na <- function(DT){
return(as.data.table(lapply(DT, function(x){replace(x, x=="",NA)})))
}
remove.head.tail <- function(DT,nb,bHead=TRUE){
DT <- as.data.table(DT)
setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
if(bHead)
DT <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
else
DT <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
return(DT)
}
#Plot la courbe de diff pour un joueur
plot.diff.curve <- function (DT,title){
if(nrow(DT) == 0)
return()
df <- data.frame(time=DT$action_de_jeu,
difficulty=DT$difficulty,
bet=DT$miseNorm)
p <- ggplot(df,aes(x=time))
p <- p + geom_step(aes(y=bet,colour="Bet"))
if(length(DT$obj.diff) > 0)
p <- p + geom_step(aes(y=DT$obj.diff,colour="Objective Difficulty"))
else
p <- p + geom_step(aes(y=difficulty,colour="Difficulty parameter"))
p <- p + ylim(0, 1)
p <- p + scale_colour_manual(
values = c("Difficulty parameter" = "red",
"Objective Difficulty" = "pink",
"Bet" = "blue"))
p <- p  +  ggtitle(title);
print(p)
}
#------------------------------------------------------
#                  LOADING DATA
#------------------------------------------------------
# Data from game trace
fileGameTrace = "./log_thomas_XPFINALES_WEEK2.txt" #résultats jeux XP CN2 avec diff DDA
#fileGameTrace = "./log_jeu_XP_NOWELL.txt" #résultats jeux XP CN2 avec diff RANDOM
DTGame <- read.csv(fileGameTrace,header=TRUE,sep=";")
DTGame <- as.data.table(DTGame)
DTGame <- set.empty.to.na(DTGame)
DTGame <- remove.na.cols(DTGame)
DTGame <- remove.na.rows(DTGame)
DTAll <- DTGame #pour n'avoir que les données tirées du jeu
# Data from questionnaire
fileQuestions = "./log_questionnaire_XP_WEEK2_REWRITED.csv" #résultats questionnaire XP CN2 avec diff DDA
#fileQuestions = "./log_questionnaire_XP_NOWELL.csv" #résultats questionnaire XP CN2 avec diff RANDOM
DTQuest <- read.csv(fileQuestions,header=TRUE,sep=";")
DTQuest <- as.data.table(DTQuest)
DTQuest <- set.empty.to.na(DTQuest)
DTQuest <- remove.na.cols(DTQuest)
DTQuest <- remove.na.rows(DTQuest)
# Merging tables into one
setkey(DTGame,IDjoueur)
setkey(DTQuest,IDjoueur)
DTAll <- merge(DTGame,DTQuest, all.x=TRUE)
#------------------------------------------------------
#         ADDING VARIABLES FOR QUESTIONNAIRE
#------------------------------------------------------
# how much playing video games in general
DTAll$play.video.games = pmax(DTAll$profilJoueur2,
DTAll$profilJoueur3,
DTAll$profilJoueur4,
DTAll$profilJoueur5,
DTAll$profilJoueur6)
DTAll$play.video.games = DTAll$play.video.games / max(DTAll$play.video.games)
# how much playing board games
DTAll$play.board.games = pmax(DTAll$profilJoueur1)
DTAll$play.board.games = DTAll$play.board.games / max(DTAll$play.board.games)
# how much playing games with money
DTAll$play.money.games = pmax(DTAll$profilJoueur7)
DTAll$play.money.games = DTAll$play.money.games / max(DTAll$play.money.games)
DTAll <- DTAll[,c("profilJoueur1","profilJoueur2","profilJoueur3","profilJoueur4",
"profilJoueur5","profilJoueur6","profilJoueur7","profilJoueur8"):=NULL] #dont need them anymore
# feeling of self efficacy
cols.self.eff <- c("autoEffJoueur1","autoEffJoueur2","autoEffJoueur3","autoEffJoueur4",
"autoEffJoueur5","autoEffJoueur6","autoEffJoueur7","autoEffJoueur8",
"autoEffJoueur9","autoEffJoueur10")
DTAll = DTAll[, self.eff := rowSums(.SD,na.rm=TRUE), .SDcols = cols.self.eff]
DTAll$self.eff = DTAll$self.eff/max(DTAll$self.eff)
DTAll <- DTAll[,c("autoEffJoueur1","autoEffJoueur2","autoEffJoueur3","autoEffJoueur4",
"autoEffJoueur5","autoEffJoueur6","autoEffJoueur7","autoEffJoueur8",
"autoEffJoueur9","autoEffJoueur10"):=NULL] #dont need them anymore
# risk aversion
cols.risk.av <- c("loterie1","loterie2","loterie3","loterie4","loterie5",
"loterie6","loterie7","loterie8","loterie9","loterie10")
DTAll = DTAll[, risk.av := rowSums(.SD,na.rm=TRUE), .SDcols = cols.risk.av]
DTAll$risk.av = DTAll$risk.av/max(DTAll$risk.av)
DTAll <- DTAll[,c("loterie1","loterie2","loterie3","loterie4","loterie5",
"loterie6","loterie7","loterie8","loterie9","loterie10"):=NULL] #dont need them anymore
# clear not used data
DTAll <- DTAll[,c("jeuxFav","horodateur","prenomNom"):=NULL] #dont need them at all
#------------------------------------------------------
#         ADDING SIMPLE VARIABLES FOR GAME TRACES
#------------------------------------------------------
DTAll$perdant <- 1-DTAll$gagnant # if the player did fail on that try
DTAll$miseNorm <- DTAll$mise / 7 # normalize bet
DTAll$timeNorm <- DTAll$action_de_jeu / max(DTAll$action_de_jeu) #normalise, to compare
DTAll$confianceNorm <- DTAll$confiance / 100 #normalize player's confidence
#number of consecutive fails
gagnant = DTAll$gagnant; # tmp vector faster to read
id = DTAll$IDjoueur; # tmp vector faster to read
nbFails <- numeric(nrow(DTAll)) # tmp vector faster to write
nbFails[1] = 0;
nbFailCpt = 0;
lastID <- id[1];
for(i in 2:nrow(DTAll)){
if(id[i] != lastID){
nbFailCpt = 0;
}else{
if(gagnant[i-1] == 0){
nbFailCpt = nbFailCpt+1;
}else{
nbFailCpt = 0;
}
}
nbFails[i] <- nbFailCpt;
lastID = id[i-1];
}
DTAll$nbFail = nbFails;
#number of consecutive wins
nbWins <- numeric(nrow(DTAll)) # tmp vector faster to write
nbWins[1] = 0;
nbWinCpt = 0;
lastID <- id[1];
for(i in 2:nrow(DTAll)){
if(id[i] != lastID){
nbWinCpt = 0;
}else{
if(gagnant[i-1] == 1){
nbWinCpt = nbWinCpt+1;
}else{
nbWinCpt = 0;
}
}
nbWins[i] <- nbWinCpt;
lastID = id[i-1];
}
DTAll$nbWin = nbWins;
#sum of absolute bet variation over time, mainly to spot 1/7/1/7/1/7 behaviors
mise = DTAll$mise;
cumulDeltaMise <- numeric(nrow(DTAll))
cumulDeltaMise[1] = 0;
lastID <- id[1];
currentCumulDeltaMise = 0;
for(i in 2:nrow(DTAll)){
if(id[i] != lastID){
currentCumulDeltaMise = 0;
}else{
currentCumulDeltaMise = currentCumulDeltaMise + abs(mise[i] - mise[i-1]);
}
lastID = id[i];
cumulDeltaMise[i] = currentCumulDeltaMise;
}
DTAll$cumulDeltaMise = cumulDeltaMise;
#------------------------------------------------------
#            OUTLIERS SETUP
#------------------------------------------------------
DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]
get.outliers <- function(DTDescMLoc,DTDescSLoc,DTDescLLoc){
outliersM <- boxplot.stats(DTDescMLoc$var)$out
outliersS <- boxplot.stats(DTDescSLoc$var)$out
outliersL <- boxplot.stats(DTDescLLoc$var)$out
outliers = data.table(type=character(0),id=character(0))
setkey(outliers,id)
if(length(outliersM) > 0)
outliers = merge(outliers,data.table(id=DTDescMLoc[var %in% outliersM]$IDjoueur,type="Moteur"),by=c("id","type"),all=TRUE)
if(length(outliersS) > 0)
outliers = merge(outliers,data.table(id=DTDescSLoc[var %in% outliersS]$IDjoueur,type="Sensoriel"),by=c("id","type"),all=TRUE)
if(length(outliersL) > 0)
outliers = merge(outliers,data.table(id=DTDescLLoc[var %in% outliersL]$IDjoueur,type="Logique"),by=c("id","type"),all=TRUE)
return(outliers)
}
plot.outliers <- function(DT,title){
p <- ggplot(DT,
aes(type,var)) +
xlab("Difficulty Type") +
ylab(title)
p <- p + geom_boxplot() + geom_point(shape=1)
print(p)
}
#------------------------------------------------------
#            OUTLIERS BET STD DEV
#------------------------------------------------------
DTDescM = DTM[,.(type="Moteur",var=sd(miseNorm)),by=IDjoueur]
DTDescS = DTS[,.(type="Sensoriel",var=sd(miseNorm)),by=IDjoueur]
DTDescL = DTL[,.(type="Logique",var=sd(miseNorm)),by=IDjoueur]
plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Bet Standard Dev");
outliers = get.outliers(DTDescM,DTDescS,DTDescL)
print(paste("Outliers :",toString(outliers$id)))
DTM[IDjoueur %in% unlist(outliers[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Motor Task");NULL},by=.(IDjoueur)]
DTS[IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliers[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Logical Task");NULL},by=.(IDjoueur)]
#------------------------------------------------------
#            OUTLIERS SUM OF WINS
#------------------------------------------------------
# Difficulty : win sum
# DTDescM = DTM[,.(type="Moteur",var=sum(gagnant)),by=IDjoueur]
# DTDescS = DTS[,.(type="Sensoriel",var=sum(gagnant)),by=IDjoueur]
# DTDescL = DTL[,.(type="Logique",var=sum(gagnant)),by=IDjoueur]
#
# plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Win Sum");
#
# outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
# outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
# print(paste("Outliers :",toString(outliersLoc$id)))
#
# DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Motor Task");NULL},by=.(IDjoueur)]
# DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Sensory Task");NULL},by=.(IDjoueur)]
# DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Logical Task");NULL},by=.(IDjoueur)]
#------------------------------------------------------
#            OUTLIERS SAVED SHEEPS
#------------------------------------------------------
# Difficulty and strategy = saved sheeps
DTDescM = DTM[,.(type="Moteur",var=max(moutons_sauves)),by=IDjoueur]
DTDescS = DTS[,.(type="Sensoriel",var=max(moutons_sauves)),by=IDjoueur]
DTDescL = DTL[,.(type="Logique",var=max(moutons_sauves)),by=IDjoueur]
plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Saved sheeps");
outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
print(paste("Outliers :",toString(outliersLoc$id)))
DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Score Motor Task");NULL},by=.(IDjoueur)]
DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Score Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Score Logical Task");NULL},by=.(IDjoueur)]
#------------------------------------------------------
#            OUTLIERS EXPLOIT DDA
#------------------------------------------------------
# DDA Exploit : Win/Fail delta sum max
DTDescM = DTM[,.(type="Moteur",var=max(cumulDeltaMise)),by=IDjoueur]
DTDescS = DTS[,.(type="Sensoriel",var=max(cumulDeltaMise)),by=IDjoueur]
DTDescL = DTL[,.(type="Logique",var=max(cumulDeltaMise)),by=IDjoueur]
plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Win/Fail delta sum max");
outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
print(paste("Outliers :",toString(outliersLoc$id)))
DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Motor Task");NULL},by=.(IDjoueur)]
DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Logical Task");NULL},by=.(IDjoueur)]
#------------------------------------------------------
#            OUTLIERS SUMMARY
#------------------------------------------------------
print(paste("Total number of outliers: ",toString(nrow(unique(outliers,by="id")))))
print(paste("Total number of outliers motor task: ",toString(nrow(unique(outliers[type=="Moteur"],by="id")))))
print(paste("Total number of outliers perceptive task: ",toString(nrow(unique(outliers[type=="Logique"],by="id")))))
print(paste("Total number of outliers logical task: ",toString(nrow(unique(outliers[type=="Sensoriel"],by="id")))))
#------------------------------------------------------
#            REMOVING OUTLIERS FROM TABLES
#------------------------------------------------------
# removing all outliers
DTM <- DTM[!IDjoueur %in% unlist(outliers[type=="Moteur"]$id)]
DTS <- DTS[!IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id)]
DTL <- DTL[!IDjoueur %in% unlist(outliers[type=="Logique"]$id)]
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
#------------------------------------------------------
#            MODELING OBJECTIVE DIFFICULTY
#------------------------------------------------------
#modeling difficulty as mixed effect linear model
model.objective.diff <- function(DT){
return(glmer(perdant ~ difficulty + timeNorm + (1 | IDjoueur), data=DT,family = "binomial"(link = "logit")))
}
add.diff.obj <- function (DT,fit){
sample = data.frame(difficulty=DT$difficulty, IDjoueur=DT$IDjoueur, timeNorm=DT$timeNorm)
DT$obj.diff =  predict(fit, newdata = sample, type = "response")
return (DT)
}
model.objective.diff.basic<- function(DT){
#on divise par bins
gameplay.diff.quants = quantile(DT$difficulty,probs = seq(0, 1, 0.025)) #seq(0,1,0.025)
print(gameplay.diff.quants)
nb.bins = length(gameplay.diff.quants)-1
for(i in 1:nb.bins){
if(i == 1)
DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
else
DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
}
DTLoc = DT[,.(nb=nrow(.SD), diff.subj.sigma = sd(1-miseNorm),diff.subj = mean(1-miseNorm), obj.diff.basic=mean(perdant), gameplay=mean(difficulty)) ,by=bin.gameplay]
p = ggplot(DTLoc,aes(x=gameplay,y=obj.diff.basic)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1) + geom_point(x=DTLoc$gameplay, y=DTLoc$diff.subj, alpha = 1, size=3, color="red")
print(p)
p = ggplot(DTLoc,aes(x=obj.diff.basic,y=diff.subj)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1)
print(p)
return (DTLoc)
}
add.diff.obj.basic <- function (DT){
#on divise par bins
gameplay.diff.quants = seq(0,1,0.1)
nb.bins = length(gameplay.diff.quants)-1
for(i in 1:nb.bins){
if(i == 1)
DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
else
DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
}
DT[,obj.diff.basic:=mean(difficulty),by=bin.gameplay]
return (DT)
}
get.levels <- function(DT,fit){
fit.ranef = ranef(fit)$IDjoueur
DTLevel <- data.table(IDjoueur=rownames(fit.ranef),niveau=-fit.ranef); # ! minus, cause it's a level
setnames(DTLevel,"niveau.(Intercept)","niveau")
return(DTLevel)
}
add.levels <- function(DT,fit){
DTLevel <- get.levels(DT,fit)
return(merge(DT,DTLevel,by="IDjoueur",all=T))
}
#TODO par groupe
add.levels.groups<- function(DT){
#fit = hclust(dist(DT$niveau), "ward.D2")
#plot(fit,hang=-1)
#groups <- cutree(fit, k=3)
nbJoueur <- nrow(unique(DT,by="niveau"))
fit<-kmeans(DT$niveau,min(nbJoueur,3))
groups<-fit$cluster
DT$niveau.group = factor(groups)
levels.order = DT[order(niveau),.(ordered.group=niveau.group),by=niveau.group]
levels.factors = levels(factor(c("bad","medium","good"),levels=c("bad","medium","good"),ordered=T))
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[1]$niveau.group] <- levels.factors[1]
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[2]$niveau.group] <- levels.factors[2]
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[3]$niveau.group] <- levels.factors[3]
return(DT)
}
#------------------------------------------------------
#         SHOWING OBJECTIVE DIFFICULTY
#------------------------------------------------------
print.objective.diff.model <- function (DT,fit) {
fit.ranef = ranef(fit)$IDjoueur
fit.sum = unlist(summary(fit))
inter = fit.sum$coefficients1
beta.diff = fit.sum$coefficients2
beta.time = fit.sum$coefficients3
inter.p.val = fit.sum$coefficients10
beta.diff.p.val = fit.sum$coefficients11
beta.time.p.val = fit.sum$coefficients12
fit.r.value = r.squaredGLMM(fit)[2] #R2 for mixed effect model
print(table(DT$nom_du_jeu))
print("Player levels from ranef:")
print(summary(fit.ranef))
print(paste("Intercept:",format.coef(inter,inter.p.val)))
print(paste("Difficulty:",format.coef(beta.diff,beta.diff.p.val)))
print(paste("Time:",format.coef(beta.time,beta.time.p.val)))
print(paste("R2:",signif(fit.r.value,digits=3)))
}
plot.objective.diff.model.curves <- function (DT,fit,time=1,groups=F) {
#DTLevel <- get.levels(DT,fit)
DTLevel <- unique(DT,by="IDjoueur")
if(groups){
DTLevel[niveau.group=="bad",group.color:=as.character("green")]
DTLevel[niveau.group=="medium",group.color:=as.character("yellow")]
DTLevel[niveau.group=="good",group.color:=as.character("cyan")]
}else{
DTLevel[niveau.group=="bad",group.color:=as.character("black")]
DTLevel[niveau.group=="medium",group.color:=as.character("black")]
DTLevel[niveau.group=="good",group.color:=as.character("black")]
}
for(i in 1:nrow(DTLevel)){
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=DTLevel[i]$IDjoueur, timeNorm=time)#TODO plusieurs temps
newres = predict(fit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),
IDjoueur = DTLevel[i]$IDjoueur,
estDiff = newres,
group.color = DTLevel[i]$group.color)
if(i==1){
p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 0.2,colour=DT$group.color) + xlim(0,1) + ylim(0,1)
} else {
p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 0.2,size=1,colour=DT$group.color)
}
}
DTLevel = DTLevel[order(abs(niveau))];
joueurMed = DTLevel[1]$IDjoueur
level.quants = quantile(DTLevel$niveau,probs = seq(0, 1, 0.25))
print(level.quants)
DTLevel = DTLevel[order(abs(niveau - (level.quants[2])))];
joueurMin = DTLevel[1]$IDjoueur
DTLevel = DTLevel[order(abs(niveau - (level.quants[4])))];
joueurMax = DTLevel[1]$IDjoueur
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMed, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="blue",size=1.3,linetype="dashed")
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMin, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMin, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMax, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMax, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),obj.diff.basic = DT, estDiff = newres)
p = p + geom_path(x=DT$difficulty,y=DT$obj.diff.basic,colour="green",size=1.01,linetype="dashed")
p <- p + theme(legend.position="none")
p <- p + xlab("Gameplay Variable") + ylab("Objective Difficulty")
print(p)
}
plot.objective.diff.model.curves.time <- function (DT,fit) {
DTLevel <- unique(DT,by="IDjoueur")
DTLevelOrder = DTLevel[order(abs(niveau))]
joueurMed = DTLevelOrder[1]$IDjoueur
cols <- colorRampPalette(brewer.pal(9,"Spectral"))(11)
for(i in 0:10){
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=i/10)#TODO plusieurs temps
newres = predict(fit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),
IDjoueur = joueurMed,
estDiff = newres,
timeNorm = i/10)
if(i==0){
p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 1,color=cols[i+1]) + xlim(0,1) + ylim(0,1)
} else {
p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 1,size=1,color=cols[i+1])
}
}
p <- p + theme(legend.position="none")
print(p)
}
plot.objective.diff.density <- function (DT) {
p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_bin2d(binwidth=c(1,0.05))
print(p)
}
plot.objective.diff.smooth <- function (DT) {
p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_point(alpha=0.5) + geom_smooth()
print(p)
}
fit.diff.motor <- model.objective.diff(DTM)
DTM <- add.diff.obj(DTM,fit.diff.motor)
DTM <- add.diff.obj.basic(DTM)
DTM <- add.levels(DTM,fit.diff.motor)
DTM <- add.levels.groups(DTM)
print.objective.diff.model(DTM,fit.diff.motor)
plot.objective.diff.model.curves(DTM,fit.diff.motor,0)
