DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Score Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Score Logical Task");NULL},by=.(IDjoueur)]
#------------------------------------------------------
#            OUTLIERS EXPLOIT DDA
#------------------------------------------------------
# DDA Exploit : Win/Fail delta sum max
DTDescM = DTM[,.(type="Moteur",var=max(cumulDeltaMise)),by=IDjoueur]
DTDescS = DTS[,.(type="Sensoriel",var=max(cumulDeltaMise)),by=IDjoueur]
DTDescL = DTL[,.(type="Logique",var=max(cumulDeltaMise)),by=IDjoueur]
plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Win/Fail delta sum max");
outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
print(paste("Outliers :",toString(outliersLoc$id)))
DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Motor Task");NULL},by=.(IDjoueur)]
DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Logical Task");NULL},by=.(IDjoueur)]
#------------------------------------------------------
#            OUTLIERS SUMMARY
#------------------------------------------------------
print(paste("Total number of outliers: ",toString(nrow(unique(outliers,by="id")))))
print(paste("Total number of outliers motor task: ",toString(nrow(unique(outliers[type=="Moteur"],by="id")))))
print(paste("Total number of outliers perceptive task: ",toString(nrow(unique(outliers[type=="Logique"],by="id")))))
print(paste("Total number of outliers logical task: ",toString(nrow(unique(outliers[type=="Sensoriel"],by="id")))))
#------------------------------------------------------
#            REMOVING OUTLIERS FROM TABLES
#------------------------------------------------------
# removing all outliers
DTM <- DTM[!IDjoueur %in% unlist(outliers[type=="Moteur"]$id)]
DTS <- DTS[!IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id)]
DTL <- DTL[!IDjoueur %in% unlist(outliers[type=="Logique"]$id)]
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
#------------------------------------------------------
#            MODELING OBJECTIVE DIFFICULTY
#------------------------------------------------------
#modeling difficulty as mixed effect linear model
model.objective.diff <- function(DT){
return(glmer(perdant ~ difficulty + timeNorm + (1 | IDjoueur), data=DT,family = "binomial"(link = "logit")))
}
add.diff.obj <- function (DT,fit){
sample = data.frame(difficulty=DT$difficulty, IDjoueur=DT$IDjoueur, timeNorm=DT$timeNorm)
DT$obj.diff =  predict(fit, newdata = sample, type = "response")
return (DT)
}
#cross val difficulty model
get.model.accuracy <- function(DT){
DT$cross.val.group = round(runif(nrow(DT),0.5,10.5))
totAccuracy <- 0
for(i in 1:10){
DTModel <-  DT[cross.val.group != i]
DTTest <- DT[cross.val.group == i]
fit <- model.objective.diff(DTModel)
newres = predict(fit, newdata = DTTest, type = "response")
newres = round(newres)
accuracy = abs(newres - DTTest$perdant)
localAccu = table(accuracy)[[1]]/length(accuracy)
totAccuracy <-  totAccuracy + localAccu
#print(localAccu)
}
totAccuracy = totAccuracy / 10
return (totAccuracy)
}
model.objective.diff.basic<- function(DT){
#on divise par bins
gameplay.diff.quants = quantile(DT$difficulty,probs = seq(0, 1, 0.025)) #seq(0,1,0.025)
print(gameplay.diff.quants)
nb.bins = length(gameplay.diff.quants)-1
for(i in 1:nb.bins){
if(i == 1)
DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
else
DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
}
DTLoc = DT[,.(nb=nrow(.SD), diff.subj.sigma = sd(1-miseNorm),diff.subj = mean(1-miseNorm), obj.diff.basic=mean(perdant), gameplay=mean(difficulty)) ,by=bin.gameplay]
p = ggplot(DTLoc,aes(x=gameplay,y=obj.diff.basic)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1) + geom_point(x=DTLoc$gameplay, y=DTLoc$diff.subj, alpha = 1, size=3, color="red")
print(p)
p = ggplot(DTLoc,aes(x=obj.diff.basic,y=diff.subj)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1)
print(p)
return (DTLoc)
}
add.diff.obj.basic <- function (DT){
#on divise par bins
gameplay.diff.quants = seq(0,1,0.1)
nb.bins = length(gameplay.diff.quants)-1
for(i in 1:nb.bins){
if(i == 1)
DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
else
DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
}
DT[,obj.diff.basic:=mean(difficulty),by=bin.gameplay]
return (DT)
}
get.levels <- function(DT,fit){
fit.ranef = ranef(fit)$IDjoueur
DTLevel <- data.table(IDjoueur=rownames(fit.ranef),niveau=-fit.ranef); # ! minus, cause it's a level
setnames(DTLevel,"niveau.(Intercept)","niveau")
return(DTLevel)
}
add.levels <- function(DT,fit){
DTLevel <- get.levels(DT,fit)
return(merge(DT,DTLevel,by="IDjoueur",all=T))
}
#TODO par groupe
add.levels.groups<- function(DT){
#fit = hclust(dist(DT$niveau), "ward.D2")
#plot(fit,hang=-1)
#groups <- cutree(fit, k=3)
nbJoueur <- nrow(unique(DT,by="niveau"))
fit<-kmeans(DT$niveau,min(nbJoueur,3))
groups<-fit$cluster
DT$niveau.group = factor(groups)
levels.order = DT[order(niveau),.(ordered.group=niveau.group),by=niveau.group]
levels.factors = levels(factor(c("bad","medium","good"),levels=c("bad","medium","good"),ordered=T))
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[1]$niveau.group] <- levels.factors[1]
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[2]$niveau.group] <- levels.factors[2]
levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[3]$niveau.group] <- levels.factors[3]
return(DT)
}
#------------------------------------------------------
#         SHOWING OBJECTIVE DIFFICULTY
#------------------------------------------------------
print.objective.diff.model <- function (DT,fit) {
print(summary(fit))
fit.ranef = ranef(fit)$IDjoueur
fit.sum = unlist(summary(fit))
inter = fit.sum$coefficients1
beta.diff = fit.sum$coefficients2
beta.time = fit.sum$coefficients3
inter.p.val = fit.sum$coefficients10
beta.diff.p.val = fit.sum$coefficients11
beta.time.p.val = fit.sum$coefficients12
fit.r.value.fix = r.squaredGLMM(fit)[1] #R2 for fixed effect model
fit.r.value.mix = r.squaredGLMM(fit)[2] #R2 for mixed effect model
fit.cross.val = get.model.accuracy(DT)
fit.aic = AIC(fit)
print(table(DT$nom_du_jeu))
print("Player levels from ranef:")
print(summary(fit.ranef))
print(paste("Intercept:",format.coef(inter,inter.p.val)))
print(paste("Difficulty:",format.coef(beta.diff,beta.diff.p.val)))
print(paste("Time:",format.coef(beta.time,beta.time.p.val)))
print(paste("R2 fixed:",signif(fit.r.value.fix,digits=2)))
print(paste("R2 mixed:",signif(fit.r.value.mix,digits=2)))
print(paste("Cross Val:",signif(fit.cross.val,digits=2)))
print(paste("AIC:",signif(fit.aic,digits=2)))
}
plot.objective.diff.model.curves <- function (DT,fit,time=1,groups=T) {
#DTLevel <- get.levels(DT,fit)
DTLevel <- unique(DT,by="IDjoueur")
if(groups){
DTLevel[niveau.group=="bad",group.color:=as.character("yellow")]
DTLevel[niveau.group=="medium",group.color:=as.character("cyan")]
DTLevel[niveau.group=="good",group.color:=as.character("green")]
}else{
DTLevel[niveau.group=="bad",group.color:=as.character("black")]
DTLevel[niveau.group=="medium",group.color:=as.character("black")]
DTLevel[niveau.group=="good",group.color:=as.character("black")]
}
for(i in 1:nrow(DTLevel)){
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=DTLevel[i]$IDjoueur, timeNorm=time)#TODO plusieurs temps
newres = predict(fit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),
IDjoueur = DTLevel[i]$IDjoueur,
estDiff = newres,
group.color = DTLevel[i]$group.color)
if(i==1){
p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 0.2,colour=DT$group.color) + xlim(0,1) + ylim(0,1)
} else {
p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 0.2,size=1,colour=DT$group.color)
}
}
DTLevel = DTLevel[order(abs(niveau))];
joueurMed = DTLevel[1]$IDjoueur
level.quants = quantile(DTLevel$niveau,probs = seq(0, 1, 0.25))
print(level.quants)
DTLevel = DTLevel[order(abs(niveau - (level.quants[2])))];
joueurMin = DTLevel[1]$IDjoueur
DTLevel = DTLevel[order(abs(niveau - (level.quants[4])))];
joueurMax = DTLevel[1]$IDjoueur
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMed, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="blue",size=1.3,linetype="dashed")
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMin, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMin, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMax, timeNorm=time)
newres = predict(fit, newdata = sample, type = "response")
DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMax, estDiff = newres)
p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
p <- p + theme(legend.position="none")
p <- p + xlab("Difficulty Variable") + ylab("Objective Difficulty") + theme(text = element_text(size=20))
print(p)
}
plot.objective.diff.model.curves.time <- function (DT,fit) {
DTLevel <- unique(DT,by="IDjoueur")
DTLevelOrder = DTLevel[order(abs(niveau))]
joueurMed = DTLevelOrder[1]$IDjoueur
cols <- colorRampPalette(brewer.pal(9,"Spectral"))(11)
for(i in 0:10){
sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=i/10)#TODO plusieurs temps
newres = predict(fit, newdata = sample, type = "response")
DT = data.table(difficulty=seq(0, 1, 0.05),
IDjoueur = joueurMed,
estDiff = newres,
timeNorm = i/10)
if(i==0){
p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 1,color=cols[i+1]) + xlim(0,1) + ylim(0,1)
} else {
p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 1,size=1,color=cols[i+1])
}
}
p <- p + theme(legend.position="none")
print(p)
}
plot.objective.diff.density <- function (DT) {
p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_bin2d(binwidth=c(1,0.05))
print(p)
}
plot.objective.diff.smooth <- function (DT,selGroup,title) {
if(selGroup != "all")
DT = DT[niveau.group==selGroup]
p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_point(alpha=0.5) + geom_smooth() + xlab("Time (turns)") + ylab("Objective Difficulty") + theme(text = element_text(size=20)) + ggtitle(title)
print(p)
}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY MOTOR TASK
#------------------------------------------------------
fit.diff.motor <- model.objective.diff(DTM)
DTM <- add.diff.obj(DTM,fit.diff.motor)
DTM <- add.diff.obj.basic(DTM)
DTM <- add.levels(DTM,fit.diff.motor)
DTM <- add.levels.groups(DTM)
print.objective.diff.model(DTM,fit.diff.motor)
plot.objective.diff.model.curves(DTM,fit.diff.motor,0)
plot.objective.diff.model.curves(DTM,fit.diff.motor,1)
plot.objective.diff.model.curves.time(DTM,fit.diff.motor)
plot.objective.diff.density(DTM)
plot.objective.diff.smooth(DTM,"all", "motor all")
plot.objective.diff.smooth(DTM,"bad", "motor bad")
plot.objective.diff.smooth(DTM,"medium", "motor medium")
plot.objective.diff.smooth(DTM,"good", "motor good")
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY SENSORY TASK
#------------------------------------------------------
fit.diff.senso <- model.objective.diff(DTS)
DTS <- add.diff.obj(DTS,fit.diff.senso)
DTS <- add.diff.obj.basic(DTS)
DTS <- add.levels(DTS,fit.diff.senso)
DTS <- add.levels.groups(DTS)
print.objective.diff.model(DTS,fit.diff.senso)
plot.objective.diff.model.curves(DTS,fit.diff.senso,0)
plot.objective.diff.model.curves(DTS,fit.diff.senso,1)
plot.objective.diff.model.curves.time(DTS,fit.diff.senso)
plot.objective.diff.density(DTS)
plot.objective.diff.smooth(DTS,"all", "sensory all")
plot.objective.diff.smooth(DTS,"bad", "sensory bad")
plot.objective.diff.smooth(DTS,"medium", "sensory medium")
plot.objective.diff.smooth(DTS,"good", "sensory good")
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY LOGICAL TASK
#------------------------------------------------------
fit.diff.logic <- model.objective.diff(DTL)
DTL <- add.diff.obj(DTL,fit.diff.logic)
DTL <- add.diff.obj.basic(DTL)
DTL <- add.levels(DTL,fit.diff.logic)
DTL <- add.levels.groups(DTL)
print.objective.diff.model(DTL,fit.diff.logic)
plot.objective.diff.model.curves(DTL,fit.diff.logic,0)
plot.objective.diff.model.curves(DTL,fit.diff.logic,1)
plot.objective.diff.model.curves.time(DTL,fit.diff.logic)
plot.objective.diff.density(DTL)
plot.objective.diff.smooth(DTL,"all", "logical all")
plot.objective.diff.smooth(DTL,"bad", "logical bad")
plot.objective.diff.smooth(DTL,"medium", "logical medium")
plot.objective.diff.smooth(DTL,"good", "logical good")
#------------------------------------------------------
#       MERGE INTO DTALL
#------------------------------------------------------
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
#------------------------------------------------------
#        MODELING SUBJECTIVE DIFFICULTY
#------------------------------------------------------
#adding error between subjective difficulty and objective difficulty
DTAll$subj.diff.mise = 1 - DTAll$miseNorm;
DTAll$error.subj.diff.mise = DTAll$subj.diff.mise - DTAll$obj.diff
DTAll <- DTAll[,error.subj.diff.mise.mean:=mean(error.subj.diff.mise),by=IDjoueur]
#evaluating confidence as a damped over time sum of win and fails;
#each win and fail importance based on objective difficulty at that time
id = DTAll$IDjoueur; # tmp vector faster to read
cur.confidence = 0;
cur.confidence.liss = 0;
lastID <- id[1];
est.confidence <- numeric(nrow(DTAll))
est.confidence[1] = 0;
obj.diff = DTAll$obj.diff
alpha <- 0.9
i = 1
for(i in 2:nrow(DTAll)){
if(id[i] != lastID){
cur.confidence.liss = 0;
}else{
if(gagnant[i-1]){
cur.confidence = obj.diff[i-1];
}else{
cur.confidence = -(1 - obj.diff[i-1]);
}
cur.confidence.liss <- alpha * cur.confidence.liss + cur.confidence;
}
lastID <- id[i];
est.confidence[i] <- cur.confidence.liss;
}
DTAll$est.confidence = est.confidence;
DTAll$est.confidence.norm = exp(DTAll$est.confidence) / (1+exp(DTAll$est.confidence));
#update DTM DTS and DTL
DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]
#OLD REPRESENTATION
# hist(unique(DTM,by="IDjoueur")$age,breaks=30,main="Age of players")
# hist(unique(DTM,by="IDjoueur")$sexe,main="Sex of players")
# hist(unique(DTM,by="IDjoueur")$play.video.games,main="Playing Video Games")
# hist(unique(DTM,by="IDjoueur")$play.board.games,main="Playing Board Games")
# hist(unique(DTM,by="IDjoueur")$self.eff,main="Self efficacy")
# hist(unique(DTM,by="IDjoueur")$risk.av,main="Risk aversion")
#âge des participants
counts <- table(unique(DTAll,by="IDjoueur")$age)
bpAge <- barplot(counts,
col = c("lightblue", "lightgreen"),
xlab="Age",
ylab="Distribution by participants",
ylim = c(0, 15))
text(bpAge, 0, round(counts, 1),cex=0.5,pos=3)
#niveau d'étude
precounts <- unique(DTAll,by="IDjoueur")$niveauEtude
counts <- table(factor(precounts,levels=1:9))
bpEtudes <- barplot(counts, main="Certificate levels", horiz=FALSE,
names.arg=c("None", "BEPC", "BEP/CAP", "BAC", "BAC+2", "BAC+3", "BAC+4", "BAC+5", "BAC+8"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
xlab="Certificate levels",
ylab="Distribution by participants",
xlim = c(0, 10),
ylim = c(0, 35),
cex.names=0.8)
text(bpEtudes, 0, round(counts, 1),cex=0.5,pos=3)
#sexe des joueurs
counts <- table(unique(DTAll,by="IDjoueur")$sexe)
bpSexe <- barplot(counts, main="Genre of players", horiz=FALSE,
names.arg=c("Male", "Female"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
col = c("lightblue", "lightgreen"),
xlab="Genre of players",
ylab="Distribution by participants",
xlim = c(0, 3),
ylim = c(0, 60),
cex.names=1)
text(bpSexe, 0, round(counts, 1),cex=0.8,pos=3)
#joueurs de jeux vidéo
counts <- table(unique(DTAll,by="IDjoueur")$play.video.games)
bpVideoGames <- barplot(counts, main="Playing Video Games", horiz=FALSE,
names.arg=c("Never", "Almost never", "Monthly", "Weekly", "Daily"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Playing Video Games",
ylab="Distribution by participants",
xlim = c(0, 6),
ylim = c(0, 50),
cex.names=1)
text(bpVideoGames, 0, round(counts, 1),cex=0.8,pos=3)
#joueurs de jeux de société
counts <- table(unique(DTAll,by="IDjoueur")$play.board.games)
bpBoardGames <- barplot(counts, main="Playing Board Games", horiz=FALSE,
names.arg=c("Never", "Almost never", "Monthly", "Weekly", "Daily"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Playing Board Games",
ylab="Distribution by participants",
xlim = c(0, 6),
ylim = c(0, 35),
cex.names=1)
text(bpBoardGames, 0, round(counts, 1),cex=0.8,pos=3)
#sentiment d'auto-efficacité
#counts <- table(unique(DTM,by="IDjoueur")$self.eff)
counts <- table(exclude = NA, unique(DTAll,by="IDjoueur")$self.eff) #ne garder que les joueurs de jeux vidéo (donc                                                                        self.eff > 0)
bpSelfEff <- barplot(counts, main="Self-efficacy in video games", horiz=FALSE,
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Self-efficacy in video games",
ylab="Distribution by video games players",
#xlim = c(0, 30),
ylim = c(0, 8),
cex.names=0.8)
text(bpSelfEff, 0, round(counts, 1),cex=0.8,pos=3)
legend("topright", legend = "From 0.5 as Medium to 1 as Strong")
#aversion au risque
counts <- table(unique(DTAll,by="IDjoueur")$risk.av)
bpRiskAver <- barplot(counts, main="Risk aversion", horiz=FALSE,
names.arg=c("Very highly risk loving", "Highly risk loving", "Risk loving", "Risk neutral", "Slightly risk averse", "Risk averse", "Very risk averse", "Highly risk averse", "stay in bed"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Risk aversion",
ylab="Distribution by participants",
xlim = c(0, 10),
ylim = c(0, 20),
cex.names=0.9)
#OLD REPRESENTATION
# hist(unique(DTM,by="IDjoueur")$age,breaks=30,main="Age of players")
# hist(unique(DTM,by="IDjoueur")$sexe,main="Sex of players")
# hist(unique(DTM,by="IDjoueur")$play.video.games,main="Playing Video Games")
# hist(unique(DTM,by="IDjoueur")$play.board.games,main="Playing Board Games")
# hist(unique(DTM,by="IDjoueur")$self.eff,main="Self efficacy")
# hist(unique(DTM,by="IDjoueur")$risk.av,main="Risk aversion")
#âge des participants
counts <- table(unique(DTAll,by="IDjoueur")$age)
bpAge <- barplot(counts,
col = c("lightblue", "lightgreen"),
xlab="Age",
ylab="Distribution by participants",
ylim = c(0, 15))
text(bpAge, 0, round(counts, 1),cex=0.5,pos=3)
#niveau d'étude
precounts <- unique(DTAll,by="IDjoueur")$niveauEtude
counts <- table(factor(precounts,levels=1:9))
bpEtudes <- barplot(counts, main="Certificate levels", horiz=FALSE,
names.arg=c("None", "BEPC", "BEP/CAP", "BAC", "BAC+2", "BAC+3", "BAC+4", "BAC+5", "BAC+8"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
xlab="Certificate levels",
ylab="Distribution by participants",
xlim = c(0, 10),
ylim = c(0, 35),
cex.names=0.8)
text(bpEtudes, 0, round(counts, 1),cex=0.5,pos=3)
#sexe des joueurs
counts <- table(unique(DTAll,by="IDjoueur")$sexe)
bpSexe <- barplot(counts, main="Genre of players", horiz=FALSE,
names.arg=c("Male", "Female"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
col = c("lightblue", "lightgreen"),
xlab="Genre of players",
ylab="Distribution by participants",
xlim = c(0, 3),
ylim = c(0, 60),
cex.names=1)
text(bpSexe, 0, round(counts, 1),cex=0.8,pos=3)
#joueurs de jeux vidéo
counts <- table(unique(DTAll,by="IDjoueur")$play.video.games)
bpVideoGames <- barplot(counts, main="Playing Video Games", horiz=FALSE,
names.arg=c("Never", "Almost never", "Monthly", "Weekly", "Daily"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Playing Video Games",
ylab="Distribution by participants",
xlim = c(0, 6),
ylim = c(0, 50),
cex.names=1)
text(bpVideoGames, 0, round(counts, 1),cex=0.8,pos=3)
#joueurs de jeux de société
counts <- table(unique(DTAll,by="IDjoueur")$play.board.games)
bpBoardGames <- barplot(counts, main="Playing Board Games", horiz=FALSE,
names.arg=c("Never", "Almost never", "Monthly", "Weekly", "Daily"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Playing Board Games",
ylab="Distribution by participants",
xlim = c(0, 6),
ylim = c(0, 35),
cex.names=1)
text(bpBoardGames, 0, round(counts, 1),cex=0.8,pos=3)
#sentiment d'auto-efficacité
#counts <- table(unique(DTM,by="IDjoueur")$self.eff)
counts <- table(exclude = NA, unique(DTAll,by="IDjoueur")$self.eff) #ne garder que les joueurs de jeux vidéo (donc                                                                        self.eff > 0)
bpSelfEff <- barplot(counts, main="Self-efficacy in video games", horiz=FALSE,
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Self-efficacy in video games",
ylab="Distribution by video games players",
#xlim = c(0, 30),
ylim = c(0, 8),
cex.names=0.8)
text(bpSelfEff, 0, round(counts, 1),cex=0.8,pos=3)
legend("topright", legend = "From 0.5 as Medium to 1 as Strong")
#aversion au risque
counts <- table(unique(DTAll,by="IDjoueur")$risk.av)
bpRiskAver <- barplot(counts, main="Risk aversion", horiz=FALSE,
#names.arg=c("Very highly risk loving", "Highly risk loving", "Risk loving", "Risk neutral", "Slightly risk averse", "Risk averse", "Very risk averse", "Highly risk averse", "stay in bed"),
legend.text = NULL, beside = TRUE,
axes = TRUE, axisnames = TRUE,
#col = c("lightblue", "lightgreen"),
xlab="Risk aversion",
ylab="Distribution by participants",
xlim = c(0, 10),
ylim = c(0, 20),
cex.names=0.9)
text(bpRiskAver, 0, round(counts, 1),cex=0.8,pos=3)
