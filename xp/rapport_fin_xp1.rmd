---
title: "Experiment with DDA"
output:
  html_document:
    theme: lumen
  pdf_document: default
---
```{r global.infos, echo=FALSE}

# risk aversion scores
# 0-1 : highly risk loving
#  2  : very risk loving
#  3  : risk loving
#  4  : risk neutral
#  5  : slightly risk averse
#  6  : risk averse
#  7  : very risk averse
#  8  : highly risk avers
# 9-10 : max choix sûr

# self efficacy scores
# 0 : not a player so did not answer
# de 10 à 20 : sentiment AE faible
# de 21 à 30 : sentiment AE moyen
# de 31 à 40 : sentiment AE fort
# de 41 à 50 : sentiment AE très fort

```

```{r setup, include = FALSE}
#------------------------------------------------------
#                  SETUP : PACKAGES
#------------------------------------------------------

require(xlsx)
require(plyr)
require(data.table)
require(ggplot2)
library(car)
require(lme4)
require(lmerTest)
require(Matrix)
library(usdm)
require(lattice)
require(psychometric)
require(MuMIn)
require(pyramid)
require(sjPlot)
require(arm)
library(MASS)
require(MuMIn)
require(Hmisc)
require(RColorBrewer)
#------------------------------------------------------
#              SETUP : UTILS FUNCTIONS
#------------------------------------------------------
format.pval.stars <- function(pv){
  pv = signif(pv,digits=2)
  if(pv<0.001) {
    return(paste(pv,"***"));
  }else if(pv<0.01){ 
    return(paste(pv,"**"));
  }else  if(pv<0.05){ 
    return(paste(pv,"*"));
  }else if(pv<0.1){ 
    return(paste(pv,"."));
  }else{
    return(paste(pv,":("));
  }
  return("unable to format pvalue !!");
}

format.pval.only.stars <- function(pv){
  pv = signif(pv,digits=2)
  if(pv<0.001) {
    return("***");
  }else if(pv<0.01){ 
    return("**");
  }else  if(pv<0.05){ 
    return("*");
  }else if(pv<0.1){ 
    return(".");
  }else{
    return(":(");
  }
  return("unable to format pvalue !!");
}

format.coef <- function(coef,p.val){
  return(paste(signif(coef,digits=3),format.pval.stars(p.val)))
}

remove.na.cols <- function(DT){
  return(as.data.table(DT[,which(unlist(lapply(DT, function(x)!all(is.na(x))))),with=F]))
}
remove.na.rows <- function(DT){
  return(as.data.table(DT[rowSums(is.na(DT)) != ncol(DT),]))
}
set.empty.to.na <- function(DT){
  return(as.data.table(lapply(DT, function(x){replace(x, x=="",NA)})))
}

remove.head.tail <- function(DT,nb,bHead=TRUE){
  DT <- as.data.table(DT)
  setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
  if(bHead)
    DT <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
  else
    DT <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
  return(DT)
}

#Plot la courbe de diff pour un joueur
plot.diff.curve <- function (DT,title){
  if(nrow(DT) == 0)
    return()
  df <- data.frame(time=DT$action_de_jeu,
                   difficulty=DT$difficulty,
                   bet=DT$miseNorm)
  p <- ggplot(df,aes(x=time)) 
  p <- p + geom_step(aes(y=bet,colour="Bet"))
  
  if(length(DT$obj.diff) > 0)
    p <- p + geom_step(aes(y=DT$obj.diff,colour="Objective Difficulty"))
  else
    p <- p + geom_step(aes(y=difficulty,colour="Difficulty parameter"))
 
   p <- p + ylim(0, 1)
  p <- p + scale_colour_manual(
    values = c("Difficulty parameter" = "red",
               "Objective Difficulty" = "pink",
               "Bet" = "blue"))
  p <- p  +  ggtitle(title);
  print(p)  
}

```

```{r data.loading, echo=FALSE}
#------------------------------------------------------
#                  LOADING DATA
#------------------------------------------------------

# Data from game trace
fileGameTrace = "./log_thomas_XPFINALES_WEEK2.txt" #résultats jeux XP CN2 avec diff DDA
#fileGameTrace = "./log_jeu_XP_NOWELL.txt" #résultats jeux XP CN2 avec diff RANDOM
DTGame <- read.csv(fileGameTrace,header=TRUE,sep=";")
DTGame <- as.data.table(DTGame)
DTGame <- set.empty.to.na(DTGame)
DTGame <- remove.na.cols(DTGame)
DTGame <- remove.na.rows(DTGame)
DTAll <- DTGame #pour n'avoir que les données tirées du jeu

# Data from questionnaire
fileQuestions = "./log_questionnaire_XP_WEEK2_REWRITED.csv" #résultats questionnaire XP CN2 avec diff DDA
#fileQuestions = "./log_questionnaire_XP_NOWELL.csv" #résultats questionnaire XP CN2 avec diff RANDOM
DTQuest <- read.csv(fileQuestions,header=TRUE,sep=";")
DTQuest <- as.data.table(DTQuest)
DTQuest <- set.empty.to.na(DTQuest)
DTQuest <- remove.na.cols(DTQuest)
DTQuest <- remove.na.rows(DTQuest)

# Merging tables into one
setkey(DTGame,IDjoueur)
setkey(DTQuest,IDjoueur)
DTAll <- merge(DTGame,DTQuest, all.x=TRUE)
```


```{r questionnaire.variables, echo=FALSE}
#------------------------------------------------------
#         ADDING VARIABLES FOR QUESTIONNAIRE
#------------------------------------------------------

# how much playing video games in general
DTAll$play.video.games = pmax(DTAll$profilJoueur2,
                              DTAll$profilJoueur3,
                              DTAll$profilJoueur4,
                              DTAll$profilJoueur5,
                              DTAll$profilJoueur6)
DTAll$play.video.games = DTAll$play.video.games / max(DTAll$play.video.games)

# how much playing board games
DTAll$play.board.games = pmax(DTAll$profilJoueur1)
DTAll$play.board.games = DTAll$play.board.games / max(DTAll$play.board.games)

# how much playing games with money
DTAll$play.money.games = pmax(DTAll$profilJoueur7)
DTAll$play.money.games = DTAll$play.money.games / max(DTAll$play.money.games)

DTAll <- DTAll[,c("profilJoueur1","profilJoueur2","profilJoueur3","profilJoueur4",
                   "profilJoueur5","profilJoueur6","profilJoueur7","profilJoueur8"):=NULL] #dont need them anymore

# feeling of self efficacy
cols.self.eff <- c("autoEffJoueur1","autoEffJoueur2","autoEffJoueur3","autoEffJoueur4",
                   "autoEffJoueur5","autoEffJoueur6","autoEffJoueur7","autoEffJoueur8",
                   "autoEffJoueur9","autoEffJoueur10")
DTAll = DTAll[, self.eff := rowSums(.SD,na.rm=TRUE), .SDcols = cols.self.eff]
DTAll$self.eff = DTAll$self.eff/max(DTAll$self.eff)
DTAll <- DTAll[,c("autoEffJoueur1","autoEffJoueur2","autoEffJoueur3","autoEffJoueur4",
                   "autoEffJoueur5","autoEffJoueur6","autoEffJoueur7","autoEffJoueur8",
                   "autoEffJoueur9","autoEffJoueur10"):=NULL] #dont need them anymore

# risk aversion

cols.risk.av <- c("loterie1","loterie2","loterie3","loterie4","loterie5",
                  "loterie6","loterie7","loterie8","loterie9","loterie10")
DTAll = DTAll[, risk.av := rowSums(.SD,na.rm=TRUE), .SDcols = cols.risk.av]
DTAll$risk.av = DTAll$risk.av/max(DTAll$risk.av)
DTAll <- DTAll[,c("loterie1","loterie2","loterie3","loterie4","loterie5",
                  "loterie6","loterie7","loterie8","loterie9","loterie10"):=NULL] #dont need them anymore

# clear not used data
DTAll <- DTAll[,c("jeuxFav","horodateur","prenomNom"):=NULL] #dont need them at all

```

```{r game.traces.simple.variables, echo=FALSE}
#------------------------------------------------------
#         ADDING SIMPLE VARIABLES FOR GAME TRACES
#------------------------------------------------------

DTAll$perdant <- 1-DTAll$gagnant # if the player did fail on that try
DTAll$miseNorm <- DTAll$mise / 7 # normalize bet
DTAll$timeNorm <- DTAll$action_de_jeu / max(DTAll$action_de_jeu) #normalise, to compare
DTAll$confianceNorm <- DTAll$confiance / 100 #normalize player's confidence
 
#number of consecutive fails
gagnant = DTAll$gagnant; # tmp vector faster to read
id = DTAll$IDjoueur; # tmp vector faster to read
nbFails <- numeric(nrow(DTAll)) # tmp vector faster to write
nbFails[1] = 0;
nbFailCpt = 0;
lastID <- id[1];
for(i in 2:nrow(DTAll)){
  if(id[i] != lastID){
    nbFailCpt = 0;
  }else{
    if(gagnant[i-1] == 0){
      nbFailCpt = nbFailCpt+1;
    }else{
      nbFailCpt = 0;
    }
  }
  nbFails[i] <- nbFailCpt;
  lastID = id[i-1];
}
  
DTAll$nbFail = nbFails;

#number of consecutive wins
nbWins <- numeric(nrow(DTAll)) # tmp vector faster to write
nbWins[1] = 0;
nbWinCpt = 0;
lastID <- id[1];
for(i in 2:nrow(DTAll)){
  if(id[i] != lastID){
    nbWinCpt = 0;
  }else{
    if(gagnant[i-1] == 1){
      nbWinCpt = nbWinCpt+1;
    }else{
      nbWinCpt = 0;
    }
  }
  nbWins[i] <- nbWinCpt;
  lastID = id[i-1];
}
  
DTAll$nbWin = nbWins;

#sum of absolute bet variation over time, mainly to spot 1/7/1/7/1/7 behaviors
mise = DTAll$mise;
cumulDeltaMise <- numeric(nrow(DTAll))
cumulDeltaMise[1] = 0;
lastID <- id[1];
currentCumulDeltaMise = 0;
for(i in 2:nrow(DTAll)){
  if(id[i] != lastID){
    currentCumulDeltaMise = 0;
  }else{
    currentCumulDeltaMise = currentCumulDeltaMise + abs(mise[i] - mise[i-1]);
  }
  lastID = id[i];
  cumulDeltaMise[i] = currentCumulDeltaMise;
}

DTAll$cumulDeltaMise = cumulDeltaMise;
```

# Removing Outliers

```{r removing.outliers.setup, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS SETUP
#------------------------------------------------------

DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]


get.outliers <- function(DTDescMLoc,DTDescSLoc,DTDescLLoc){
  outliersM <- boxplot.stats(DTDescMLoc$var)$out
  outliersS <- boxplot.stats(DTDescSLoc$var)$out
  outliersL <- boxplot.stats(DTDescLLoc$var)$out
  
  outliers = data.table(type=character(0),id=character(0))
  setkey(outliers,id)
  if(length(outliersM) > 0)
    outliers = merge(outliers,data.table(id=DTDescMLoc[var %in% outliersM]$IDjoueur,type="Moteur"),by=c("id","type"),all=TRUE)
  if(length(outliersS) > 0)
    outliers = merge(outliers,data.table(id=DTDescSLoc[var %in% outliersS]$IDjoueur,type="Sensoriel"),by=c("id","type"),all=TRUE)
  if(length(outliersL) > 0)
    outliers = merge(outliers,data.table(id=DTDescLLoc[var %in% outliersL]$IDjoueur,type="Logique"),by=c("id","type"),all=TRUE)
    
  return(outliers)
}

plot.outliers <- function(DT,title){
  p <- ggplot(DT, 
            aes(type,var)) + 
            xlab("Difficulty Type") + 
            ylab(title)
  p <- p + geom_boxplot() + geom_point(shape=1) 
  print(p)
}
```


```{r detect.outliers.bet.sd, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS BET STD DEV
#------------------------------------------------------
DTDescM = DTM[,.(type="Moteur",var=sd(miseNorm)),by=IDjoueur]
DTDescS = DTS[,.(type="Sensoriel",var=sd(miseNorm)),by=IDjoueur]
DTDescL = DTL[,.(type="Logique",var=sd(miseNorm)),by=IDjoueur]

plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Bet Standard Dev");

outliers = get.outliers(DTDescM,DTDescS,DTDescL)
print(paste("Outliers :",toString(outliers$id)))

DTM[IDjoueur %in% unlist(outliers[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Motor Task");NULL},by=.(IDjoueur)]
DTS[IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliers[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Bet Sd Logical Task");NULL},by=.(IDjoueur)]
```

```{r detect.outliers.win.sum, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS SUM OF WINS
#------------------------------------------------------
# Difficulty : win sum

# DTDescM = DTM[,.(type="Moteur",var=sum(gagnant)),by=IDjoueur]
# DTDescS = DTS[,.(type="Sensoriel",var=sum(gagnant)),by=IDjoueur]
# DTDescL = DTL[,.(type="Logique",var=sum(gagnant)),by=IDjoueur]
# 
# plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Win Sum");
# 
# outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
# outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
# print(paste("Outliers :",toString(outliersLoc$id)))
# 
# DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Motor Task");NULL},by=.(IDjoueur)]
# DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Sensory Task");NULL},by=.(IDjoueur)]
# DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Win Sum Logical Task");NULL},by=.(IDjoueur)]

```

```{r detect.outliers.sheeps.saved, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS SAVED SHEEPS
#------------------------------------------------------
# Difficulty and strategy = saved sheeps
DTDescM = DTM[,.(type="Moteur",var=max(moutons_sauves)),by=IDjoueur]
DTDescS = DTS[,.(type="Sensoriel",var=max(moutons_sauves)),by=IDjoueur]
DTDescL = DTL[,.(type="Logique",var=max(moutons_sauves)),by=IDjoueur]

plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Saved sheeps");

outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
print(paste("Outliers :",toString(outliersLoc$id)))

DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Score Motor Task");NULL},by=.(IDjoueur)]
DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Score Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Score Logical Task");NULL},by=.(IDjoueur)]

```

```{r detect.outliers.dda.exploit, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS EXPLOIT DDA
#------------------------------------------------------
# DDA Exploit : Win/Fail delta sum max
DTDescM = DTM[,.(type="Moteur",var=max(cumulDeltaMise)),by=IDjoueur]
DTDescS = DTS[,.(type="Sensoriel",var=max(cumulDeltaMise)),by=IDjoueur]
DTDescL = DTL[,.(type="Logique",var=max(cumulDeltaMise)),by=IDjoueur]

plot.outliers(rbind(DTDescM,rbind(DTDescL,DTDescS)), "Win/Fail delta sum max");

outliersLoc = get.outliers(DTDescM,DTDescS,DTDescL)
outliers = merge(outliers,outliersLoc,by=c("id","type"),all=TRUE)
print(paste("Outliers :",toString(outliersLoc$id)))

DTM[IDjoueur %in% unlist(outliersLoc[type=="Moteur"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Motor Task");NULL},by=.(IDjoueur)]
DTS[IDjoueur %in% unlist(outliersLoc[type=="Sensoriel"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Sensory Task");NULL},by=.(IDjoueur)]
DTL[IDjoueur %in% unlist(outliersLoc[type=="Logique"]$id) ,{plot.diff.curve(.SD,"Outlier Delta Bet Logical Task");NULL},by=.(IDjoueur)]
```

```{r detect.outliers.summary, echo=FALSE}
#------------------------------------------------------
#            OUTLIERS SUMMARY
#------------------------------------------------------
print(paste("Total number of outliers: ",toString(nrow(unique(outliers,by="id")))))
print(paste("Total number of outliers motor task: ",toString(nrow(unique(outliers[type=="Moteur"],by="id")))))
print(paste("Total number of outliers perceptive task: ",toString(nrow(unique(outliers[type=="Logique"],by="id")))))
print(paste("Total number of outliers logical task: ",toString(nrow(unique(outliers[type=="Sensoriel"],by="id")))))
```

```{r remove.outliers, echo=FALSE}
#------------------------------------------------------
#            REMOVING OUTLIERS FROM TABLES
#------------------------------------------------------
# removing all outliers
DTM <- DTM[!IDjoueur %in% unlist(outliers[type=="Moteur"]$id)]
DTS <- DTS[!IDjoueur %in% unlist(outliers[type=="Sensoriel"]$id)]
DTL <- DTL[!IDjoueur %in% unlist(outliers[type=="Logique"]$id)]
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
```

```{r modeling.difficulty.compute.utils, echo=FALSE}
#------------------------------------------------------
#            MODELING OBJECTIVE DIFFICULTY 
#------------------------------------------------------
#modeling difficulty as mixed effect linear model
model.objective.diff <- function(DT){
  return(glmer(perdant ~ difficulty + timeNorm + (1 | IDjoueur), data=DT,family = "binomial"(link = "probit")))
}

add.diff.obj <- function (DT,fit){
  sample = data.frame(difficulty=DT$difficulty, IDjoueur=DT$IDjoueur, timeNorm=DT$timeNorm)
  DT$obj.diff =  predict(fit, newdata = sample, type = "response")
  return (DT)
}

#cross val difficulty model
get.model.accuracy <- function(DT){
  DT$cross.val.group = round(runif(nrow(DT),0.5,10.5))
  totAccuracy <- 0
  for(i in 1:10){
    DTModel <-  DT[cross.val.group != i]
    DTTest <- DT[cross.val.group == i]
    fit <- model.objective.diff(DTModel)
    newres = predict(fit, newdata = DTTest, type = "response")  
    newres = round(newres)
    accuracy = abs(newres - DTTest$perdant)
    localAccu = table(accuracy)[[1]]/length(accuracy)
    totAccuracy <-  totAccuracy + localAccu
    #print(localAccu)
  }
  
  totAccuracy = totAccuracy / 10
  return (totAccuracy)
}

model.objective.diff.basic<- function(DT){
  #on divise par bins
  gameplay.diff.quants = quantile(DT$difficulty,probs = seq(0, 1, 0.025)) #seq(0,1,0.025)
  print(gameplay.diff.quants)
  nb.bins = length(gameplay.diff.quants)-1
  
  for(i in 1:nb.bins){
    if(i == 1)
      DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
    else
      DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
  }
  
  DTLoc = DT[,.(nb=nrow(.SD), diff.subj.sigma = sd(1-miseNorm),diff.subj = mean(1-miseNorm), obj.diff.basic=mean(perdant), gameplay=mean(difficulty)) ,by=bin.gameplay]
  
  p = ggplot(DTLoc,aes(x=gameplay,y=obj.diff.basic)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1) + geom_point(x=DTLoc$gameplay, y=DTLoc$diff.subj, alpha = 1, size=3, color="red")
  
  print(p)
  
  p = ggplot(DTLoc,aes(x=obj.diff.basic,y=diff.subj)) + geom_point(alpha = 1, size=3, color="green") + xlim(0,1) + ylim(0,1) 
  
  print(p)
  
  return (DTLoc)
}

add.diff.obj.basic <- function (DT){
  
  #on divise par bins
  gameplay.diff.quants = seq(0,1,0.1)
  nb.bins = length(gameplay.diff.quants)-1
  
  for(i in 1:nb.bins){
    if(i == 1)
      DT[difficulty >= gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
    else
      DT[difficulty > gameplay.diff.quants[i] & difficulty <= gameplay.diff.quants[i+1],bin.gameplay:=i]
  }
  
  DT[,obj.diff.basic:=mean(difficulty),by=bin.gameplay]

  return (DT)
}

get.levels <- function(DT,fit){
  fit.ranef = ranef(fit)$IDjoueur
  DTLevel <- data.table(IDjoueur=rownames(fit.ranef),niveau=-fit.ranef); # ! minus, cause it's a level
  setnames(DTLevel,"niveau.(Intercept)","niveau")
  return(DTLevel)
}

add.levels <- function(DT,fit){
  DTLevel <- get.levels(DT,fit)
  return(merge(DT,DTLevel,by="IDjoueur",all=T))
} 

#TODO par groupe
add.levels.groups<- function(DT){
  #fit = hclust(dist(DT$niveau), "ward.D2")
  #plot(fit,hang=-1)
  #groups <- cutree(fit, k=3) 
  nbJoueur <- nrow(unique(DT,by="niveau"))
  fit<-kmeans(DT$niveau,min(nbJoueur,3))
  groups<-fit$cluster
  DT$niveau.group = factor(groups)
  levels.order = DT[order(niveau),.(ordered.group=niveau.group),by=niveau.group]
  levels.factors = levels(factor(c("bad","medium","good"),levels=c("bad","medium","good"),ordered=T))
  
  levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[1]$niveau.group] <- levels.factors[1]
  levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[2]$niveau.group] <- levels.factors[2]
  levels(DT$niveau.group)[levels(DT$niveau.group)==levels.order[3]$niveau.group] <- levels.factors[3]

  return(DT)
}
```

```{r modeling.difficulty.draw.utils, echo=FALSE}
#------------------------------------------------------
#         SHOWING OBJECTIVE DIFFICULTY 
#------------------------------------------------------
print.objective.diff.model <- function (DT,fit) {
  print(summary(fit))
  
  fit.ranef = ranef(fit)$IDjoueur
  fit.sum = unlist(summary(fit))
  inter = fit.sum$coefficients1
  beta.diff = fit.sum$coefficients2
  beta.time = fit.sum$coefficients3
  inter.p.val = fit.sum$coefficients10
  beta.diff.p.val = fit.sum$coefficients11
  beta.time.p.val = fit.sum$coefficients12
    fit.r.value.fix = r.squaredGLMM(fit)[1] #R2 for fixed effect model
    fit.r.value.mix = r.squaredGLMM(fit)[2] #R2 for mixed effect model
  fit.cross.val = get.model.accuracy(DT)
  fit.aic = AIC(fit)
  
  print(table(DT$nom_du_jeu))
  print("Player levels from ranef:")
  print(summary(fit.ranef))
  print(paste("Intercept:",format.coef(inter,inter.p.val)))
  print(paste("Difficulty:",format.coef(beta.diff,beta.diff.p.val)))
  print(paste("Time:",format.coef(beta.time,beta.time.p.val)))
  print(paste("R2 fixed:",signif(fit.r.value.fix,digits=2)))
  print(paste("R2 mixed:",signif(fit.r.value.mix,digits=2)))
  print(paste("Cross Val:",signif(fit.cross.val,digits=2)))
  print(paste("AIC:",signif(fit.aic,digits=2)))
}

plot.objective.diff.model.curves <- function (DT,fit,time=1,groups=F) {

  #DTLevel <- get.levels(DT,fit)
  DTLevel <- unique(DT,by="IDjoueur")
  if(groups){
    DTLevel[niveau.group=="bad",group.color:=as.character("green")]
    DTLevel[niveau.group=="medium",group.color:=as.character("yellow")]
    DTLevel[niveau.group=="good",group.color:=as.character("cyan")]
  }else{
    DTLevel[niveau.group=="bad",group.color:=as.character("black")]
    DTLevel[niveau.group=="medium",group.color:=as.character("black")]
    DTLevel[niveau.group=="good",group.color:=as.character("black")]
  }
  
  for(i in 1:nrow(DTLevel)){
    sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=DTLevel[i]$IDjoueur, timeNorm=time)#TODO plusieurs temps
    newres = predict(fit, newdata = sample, type = "response")
    DT = data.table(difficulty=seq(0, 1, 0.05),
                    IDjoueur = DTLevel[i]$IDjoueur, 
                    estDiff = newres,  
                    group.color = DTLevel[i]$group.color)
    if(i==1){
      p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 0.2,colour=DT$group.color) + xlim(0,1) + ylim(0,1)
    } else {
      p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 0.2,size=1,colour=DT$group.color)
    }
  }
  
  DTLevel = DTLevel[order(abs(niveau))];
  joueurMed = DTLevel[1]$IDjoueur
  
  level.quants = quantile(DTLevel$niveau,probs = seq(0, 1, 0.25))
  print(level.quants)
  DTLevel = DTLevel[order(abs(niveau - (level.quants[2])))];
  joueurMin = DTLevel[1]$IDjoueur
  DTLevel = DTLevel[order(abs(niveau - (level.quants[4])))];
  joueurMax = DTLevel[1]$IDjoueur
  
  
  sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=time)
  newres = predict(fit, newdata = sample, type = "response")
  DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMed, estDiff = newres)
  p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="blue",size=1.3,linetype="dashed")
  
  sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMin, timeNorm=time)
  newres = predict(fit, newdata = sample, type = "response")
  DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMin, estDiff = newres)
  p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
  
  sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMax, timeNorm=time)
  newres = predict(fit, newdata = sample, type = "response")
  DTDraw = data.table(difficulty=seq(0, 1, 0.05),IDjoueur = joueurMax, estDiff = newres)
  p = p + geom_path(x=DTDraw$difficulty,y=DTDraw$estDiff,colour="red",size=1.01,linetype="dashed")
  
  p <- p + theme(legend.position="none")
  
  p <- p + xlab("Gameplay Variable") + ylab("Objective Difficulty")
  
  print(p)
}

plot.objective.diff.model.curves.time <- function (DT,fit) {

  
  DTLevel <- unique(DT,by="IDjoueur")
  
  DTLevelOrder = DTLevel[order(abs(niveau))]
  joueurMed = DTLevelOrder[1]$IDjoueur
  
  cols <- colorRampPalette(brewer.pal(9,"Spectral"))(11)
  
  for(i in 0:10){
    sample = data.frame(difficulty=seq(0, 1, 0.05),IDjoueur=joueurMed, timeNorm=i/10)#TODO plusieurs temps
    newres = predict(fit, newdata = sample, type = "response")
    DT = data.table(difficulty=seq(0, 1, 0.05),
                    IDjoueur = joueurMed, 
                    estDiff = newres,
                    timeNorm = i/10)
    if(i==0){
      p = ggplot(DT,aes(x=difficulty,y=estDiff)) + geom_path(alpha = 1,color=cols[i+1]) + xlim(0,1) + ylim(0,1)
    } else {
      p = p + geom_path(x=DT$difficulty,y=DT$estDiff, alpha = 1,size=1,color=cols[i+1])
    }
  }
  
  p <- p + theme(legend.position="none")

  print(p)
}

plot.objective.diff.density <- function (DT) {
  p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_bin2d(binwidth=c(1,0.05))
  print(p)
}

plot.objective.diff.smooth <- function (DT) {
  p <- ggplot(DT, aes(action_de_jeu, obj.diff)) + geom_point(alpha=0.5) + geom_smooth()
  print(p)
}
```

##Modeling objective difficulty for motor task

```{r modeling.difficulty.motor, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY MOTOR TASK
#------------------------------------------------------
  fit.diff.motor <- model.objective.diff(DTM)
  DTM <- add.diff.obj(DTM,fit.diff.motor)
  DTM <- add.diff.obj.basic(DTM)
  DTM <- add.levels(DTM,fit.diff.motor)
  DTM <- add.levels.groups(DTM)
  print.objective.diff.model(DTM,fit.diff.motor)
  plot.objective.diff.model.curves(DTM,fit.diff.motor,0)
  plot.objective.diff.model.curves(DTM,fit.diff.motor,1)
  plot.objective.diff.model.curves.time(DTM,fit.diff.motor)
  plot.objective.diff.density(DTM)
  plot.objective.diff.smooth(DTM)
```

##Modeling objective difficulty for sensory task

```{r modeling.difficulty.sensory, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY SENSORY TASK
#------------------------------------------------------
  fit.diff.senso <- model.objective.diff(DTS)
  DTS <- add.diff.obj(DTS,fit.diff.senso)
  DTS <- add.diff.obj.basic(DTS)
  DTS <- add.levels(DTS,fit.diff.senso)
  DTS <- add.levels.groups(DTS)
  print.objective.diff.model(DTS,fit.diff.senso)
  plot.objective.diff.model.curves(DTS,fit.diff.senso,0)
  plot.objective.diff.model.curves(DTS,fit.diff.senso,1)
  plot.objective.diff.model.curves.time(DTS,fit.diff.senso)
  plot.objective.diff.density(DTS)
  plot.objective.diff.smooth(DTS)
```

##Modeling objective difficulty for logical task

```{r modeling.difficulty.logical, echo=FALSE}
#------------------------------------------------------
#        MODELING OBJECTIVE DIFFICULTY LOGICAL TASK
#------------------------------------------------------
  fit.diff.logic <- model.objective.diff(DTL)
  DTL <- add.diff.obj(DTL,fit.diff.logic)
  DTL <- add.diff.obj.basic(DTL)
  DTL <- add.levels(DTL,fit.diff.logic)
  DTL <- add.levels.groups(DTL)
  print.objective.diff.model(DTL,fit.diff.logic)
  plot.objective.diff.model.curves(DTL,fit.diff.logic,0)
  plot.objective.diff.model.curves(DTL,fit.diff.logic,1)
  plot.objective.diff.model.curves.time(DTL,fit.diff.logic)
  plot.objective.diff.density(DTL)
  plot.objective.diff.smooth(DTL)
```

```{r modeling.difficulty.merge, echo=FALSE}  
#------------------------------------------------------
#       MERGE INTO DTALL
#------------------------------------------------------
DTAll <- data.table()
DTAll <- rbind(DTAll,DTL)
DTAll <- rbind(DTAll,DTM)
DTAll <- rbind(DTAll,DTS)
```

```{r modeling.subjective.difficulty, echo=FALSE}   
#------------------------------------------------------
#        MODELING SUBJECTIVE DIFFICULTY 
#------------------------------------------------------
#adding error between subjective difficulty and objective difficulty
DTAll$subj.diff.mise = 1 - DTAll$miseNorm;
DTAll$error.subj.diff.mise = DTAll$subj.diff.mise - DTAll$obj.diff
DTAll <- DTAll[,error.subj.diff.mise.mean:=mean(error.subj.diff.mise),by=IDjoueur]

#evaluating confidence as a damped over time sum of win and fails;
#each win and fail importance based on objective difficulty at that time
id = DTAll$IDjoueur; # tmp vector faster to read
cur.confidence = 0;
cur.confidence.liss = 0;
lastID <- id[1];
est.confidence <- numeric(nrow(DTAll))
est.confidence[1] = 0;
obj.diff = DTAll$obj.diff
alpha <- 0.9
i = 1
for(i in 2:nrow(DTAll)){
  if(id[i] != lastID){
    cur.confidence.liss = 0;
  }else{
    if(gagnant[i-1]){
      cur.confidence = obj.diff[i-1];
    }else{
      cur.confidence = -(1 - obj.diff[i-1]);
    }
    cur.confidence.liss <- alpha * cur.confidence.liss + cur.confidence;
  }
  lastID <- id[i];
  est.confidence[i] <- cur.confidence.liss;
}

DTAll$est.confidence = est.confidence;
DTAll$est.confidence.norm = exp(DTAll$est.confidence) / (1+exp(DTAll$est.confidence));

#update DTM DTS and DTL
DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]
```

#Influence of Player Profiles

##Player profiles

```{r show.player.profiles, echo=FALSE} 

hist(unique(DTM,by="IDjoueur")$age,breaks=30,main="Age of players")
hist(unique(DTM,by="IDjoueur")$sexe,main="Sex of players")
hist(unique(DTM,by="IDjoueur")$play.video.games,main="Playing Video Games")
hist(unique(DTM,by="IDjoueur")$play.board.games,main="Playing Board Games")
hist(unique(DTM,by="IDjoueur")$self.eff,main="Self efficacy")
hist(unique(DTM,by="IDjoueur")$risk.av,main="Risk aversion")
```

##Influence of Player Profiles

```{r player.model.subjective.difficulty, echo=FALSE} 
test.profile <- function(Y,X,title){
  test <- cor.test(Y,X, method="kendall")
  res <- paste(signif(test$estimate,digits=2),format.pval.stars(test$p.value))
  if(test$p.value < 0.1){
    print(paste(title,res))
  }
  return(res)
}

test.profile.binary <- function(A,B,title){
  test <- wilcox.test(B,A,conf.int=T)
  res <- paste(signif(test$estimate,digits=2),format.pval.stars(test$p.value))
  if(test$p.value < 0.1){
    res <- paste(res,paste("mean(A):",signif(mean(A),digit=2)))
    res <- paste(res,paste("mean(B):",signif(mean(B),digit=2)))
    print(paste(title,res))
  }
    
  return(res)
}

test.profile.multigroups <- function(Y,X,title){
  test <- kruskal.test(Y ~ X) 
  res <- paste(format.pval.stars(test$p.value))
  if(test$p.value < 0.1){
    print(paste(title,res))
  }
    
  return(res)
}


```

##Objective level and player profile

### Playing video games in general and level for each task

```{r echo=FALSE}
pvg.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$play.video.games,"pvg.on.level.m")
pvg.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$play.video.games,"pvg.on.level.s")
pvg.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$play.video.games,"pvg.on.level.l")
```

### Playing board games in general and level for each task

```{r echo=FALSE}
pbg.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$play.board.games,"pbg.on.level.m")
pbg.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$play.board.games,"pbg.on.level.s")
pbg.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$play.board.games,"pbg.on.level.l")
```

### Self efficacy and level for each task

```{r echo=FALSE}
self.eff.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$self.eff,"self.eff.on.level.m")
self.eff.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$self.eff,"self.eff.on.level.s")
self.eff.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$self.eff,"self.eff.on.level.l")
```

### Risk aversion and level for each task

```{r echo=FALSE}
risk.av.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$risk.av,"risk.av.on.level.m")
risk.av.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$risk.av,"risk.av.on.level.s")
risk.av.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$risk.av,"risk.av.on.level.l")
```

### Age and level for each task

```{r echo=FALSE}
age.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$age,"age.on.level.m")
age.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$age,"age.on.level.s")
age.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$age,"age.on.level.l")
```

### Sex and level for each task

```{r echo=FALSE}
sexe.on.level.m <- test.profile(unique(DTM,by="IDjoueur")$niveau, unique(DTM,by="IDjoueur")$sexe,"sexe.on.level.m")
sexe.on.level.s <- test.profile(unique(DTS,by="IDjoueur")$niveau, unique(DTS,by="IDjoueur")$sexe,"sexe.on.level.s")
sexe.on.level.l <- test.profile(unique(DTL,by="IDjoueur")$niveau, unique(DTL,by="IDjoueur")$sexe,"sexe.on.level.l")

sexe.on.level.m.2 <- test.profile.binary(unique(DTM[sexe==0],by="IDjoueur")$niveau, unique(DTM[sexe==1],by="IDjoueur")$niveau,"sexe.on.level.m.2")
sexe.on.level.s.2 <- test.profile.binary(unique(DTS[sexe==0],by="IDjoueur")$niveau, unique(DTS[sexe==1],by="IDjoueur")$niveau,"sexe.on.level.s.2")
sexe.on.level.l.2 <- test.profile.binary(unique(DTL[sexe==0],by="IDjoueur")$niveau, unique(DTL[sexe==1],by="IDjoueur")$niveau,"sexe.on.level.l.2")
```

##Subjective difficulty and play habits

###Playing video game in general and subjective difficulty error

```{r echo=FALSE}
pvg.on.error <- test.profile(unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$play.video.games,"pvg.on.error")
```

###Playing board game in general and subjective difficulty error

```{r echo=FALSE}
pbg.on.error <- test.profile(unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$play.board.games,"pbg.on.error")
```

###In game level and subjective difficulty error

```{r echo=FALSE}
niveau.group.on.error <- test.profile.multigroups(unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$niveau.group,"niveau.group.on.error")

niveau.group.on.error.m <- test.profile.multigroups(unique(DTM,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTM,by=c("IDjoueur","nom_du_jeu"))$niveau.group,"niveau.group.on.error.m")
niveau.group.on.error.s <- test.profile.multigroups(unique(DTS,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTS,by=c("IDjoueur","nom_du_jeu"))$niveau.group,"niveau.group.on.error.s")
niveau.group.on.error.l <- test.profile.multigroups(unique(DTL,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTL,by=c("IDjoueur","nom_du_jeu"))$niveau.group,"niveau.group.on.error.l")

```

###Sex and subjective difficulty error

```{r echo=FALSE}
sexe.on.error <- test.profile(unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$sexe,"sexe.on.error")

sexe.on.error.m <- test.profile(unique(DTM,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTM,by=c("IDjoueur","nom_du_jeu"))$sexe,"sexe.on.error.m")
sexe.on.error.s <- test.profile(unique(DTS,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTS,by=c("IDjoueur","nom_du_jeu"))$sexe,"sexe.on.error.s")
sexe.on.error.l <- test.profile(unique(DTL,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTL,by=c("IDjoueur","nom_du_jeu"))$sexe,"sexe.on.error.l")

sexe.on.error.2 <- test.profile.binary(unique(DTAll[sexe==0],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTAll[sexe==1],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean,"sexe.on.error.2")

sexe.on.error.m.2 <- test.profile.binary(unique(DTM[sexe==0],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTM[sexe==1],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean,"sexe.on.error.m.2")
sexe.on.error.s.2 <- test.profile.binary(unique(DTS[sexe==0],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTS[sexe==1],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean,"sexe.on.error.s.2")
sexe.on.error.l.2 <- test.profile.binary(unique(DTL[sexe==0],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTL[sexe==1],by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean,"sexe.on.error.l.2")

```

###Risk aversion and subjective difficulty error

```{r echo=FALSE}

risk.av.on.error <- test.profile(unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$risk.av,"risk.av.on.error")

```

###Self efficacy and subjective difficulty error

```{r echo=FALSE}

self.eff.on.error <- test.profile(unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$error.subj.diff.mise.mean, unique(DTAll,by=c("IDjoueur","nom_du_jeu"))$self.eff,"self.eff.on.error")
  
```

OLD!! We investigate the link between player's reported game habits, feeling of self efficacy, risk aversion and player's behavior in the different games. Feeling of self efficacy shows a small link with performance on motor task (Kendal $\tau$=0.26, p<0.01) and logical task (Kendal $\tau$=0.17, p=0.053). Aversion to risk shows a small link with performance on sensory (Kendal $\tau$=0.29, p<0.001) and logical task (Kendal $\tau$=0.27 p<0.01). In this experiment, female players tend to have a lower performance on motor (Kendal $\tau$=-0.4, p<0.001) and logical tasks (Kendal $\tau$=-0.25, p<0.01). Player's sex is also slightly related to the error between subjective and objective difficulty (Kendal $\tau$=-0.19, p=0.053) i.e. compared to male players, female players tend to underestimate logical task difficulty.

#Influence of Objective difficulty on Subjective Difficulty

```{r plot.subjective.objective.difficulty, echo=FALSE}   
#------------------------------------------------------
#     SHOWING SUBJECTIVE VS OBJECTIVE DIFFICULTY 
#------------------------------------------------------

plot.subjective.difficulty <- function(DT){
  
  # Lien entre mise normalisée et difficultée estimée (hard / easy effect)
  obj.diff.quants = seq(0,1,1/16)#quantile(DT$obj.diff, probs=(seq(0,1,0.05)))
  nb.bins = length(obj.diff.quants)-1
  subj.diff.med = numeric(nb.bins)
  obj.diff.bin = numeric(nb.bins)
  obj.diff.bin.cur = 0;
  test.pvals = numeric(nb.bins)
  conf.min = numeric(nb.bins)
  conf.max = numeric(nb.bins)
  nb.vals = numeric(nb.bins)
  delta.obj.subj = numeric(nb.bins)
  hist(DT$obj.diff)
  for(i in 1:nb.bins){
    #obj.diff.bin.cur = round(i/10,1)
    #subj.diff = DT[round(obj.diff,1)==obj.diff.bin.cur]$subj.diff.mise
    obj.diff.bin.cur = (obj.diff.quants[i] + obj.diff.quants[i+1])/2.0
    #subj.diff = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]$subj.diff.mise
    DTLoc = DT[obj.diff > obj.diff.quants[i] & obj.diff<=obj.diff.quants[i+1]]
    DTLoc = DTLoc[,.(mise.mean=mean(subj.diff.mise)),by=IDjoueur]
    subj.diff = DTLoc$mise.mean
    obj.diff.bin[i] = obj.diff.bin.cur
    subj.diff.med[i] = NA
    test.pvals[i] = NA
    conf.min[i] = NA
    conf.max[i] = NA
    delta.obj.subj[i] = NA
    nb.vals[i] = length(subj.diff)
    if(nb.vals[i] > 1){
      try.res = try(test.res <- wilcox.test(subj.diff,mu = obj.diff.bin.cur,conf.int=T))
      if (class(try.res) != "try-error"){
        print(test.res)
        #hist(subj.diff)
        test.pvals[i] = format.pval.stars(test.res$p.value)
        #subj.diff.med[i] = mean(subj.diff)
        subj.diff.med[i] = test.res$estimate
        conf.min[i] = test.res$conf.int[1]
        conf.max[i] = test.res$conf.int[2]
        delta.obj.subj[i] = signif(subj.diff.med[i] - obj.diff.bin.cur,digit=2)
      }
    }
  }
  
  #print table of pvalues
  print(data.table(obj.diff.bin=obj.diff.bin,delta.obj.subj=delta.obj.subj,n=nb.vals,pval=test.pvals))
  
  #kernel smooth
  subj.diff.smooth <- ksmooth(x=DT$obj.diff,y=DT$subj.diff.mise,bandwidth = 0.2)
  DTSmooth = data.table(x=subj.diff.smooth$x,y=subj.diff.smooth$y)
  
  DTPlot = data.table(obj.diff=obj.diff.bin,subj.diff=subj.diff.med)
 
  p = ggplot() +
 #       geom_line(aes(x=DTPouet$x,y=DTPouet$y))+
        geom_point(aes(x=DTPlot$obj.diff,y=DTPlot$subj.diff),alpha = 1, size = 3) +
        xlim(0,1)+
        ylim(0,1)+
        geom_errorbar(aes(x=DTPlot$obj.diff, ymin=conf.min, ymax=conf.max), width=.01,color="red")  +
        geom_abline(intercept = 0, slope = 1, color="blue")
  
  print(p)
}
```

##All tasks

```{r plot.subjective.difficulty.all, echo=FALSE}
plot.subjective.difficulty(DTAll)
```

##Motor task

```{r plot.subjective.difficulty.motor, echo=FALSE}
plot.subjective.difficulty(DTM)
```

##Sensory task

```{r plot.subjective.difficulty.sensory, echo=FALSE}
plot.subjective.difficulty(DTS)
```

##Logical task

```{r plot.subjective.difficulty.logical, echo=FALSE}
plot.subjective.difficulty(DTL)
```

#Influence of Playtime on Subjective Difficulty Error

```{r platytime.subjective.difficulty.funcs, echo=FALSE} 
plot.subjective.diff.error.density <- function (DT) {
  p <- ggplot(DT, aes(action_de_jeu, error.subj.diff.mise)) + geom_bin2d(binwidth=c(1,0.2))
  print(p)
}
``` 

##For all groups, motor, sensitive and logical

```{r platytime.subjective.difficulty.all, echo=FALSE} 
plot.subjective.diff.error.density <- function (DT) {
  p <- ggplot(DT, aes(action_de_jeu, error.subj.diff.mise)) + geom_bin2d(binwidth=c(1,0.2))
  print(p)
}
 

plot.subjective.diff.error.density(DTM)
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTM))
plot.subjective.diff.error.density(DTS)
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTS))
plot.subjective.diff.error.density(DTL)
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTL))


``` 

##Per group, motor task

```{r platytime.subjective.difficulty.group.motor, echo=FALSE} 
plot.subjective.diff.error.density(DTM[niveau.group=="bad"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTM[niveau.group=="bad"]))
plot.subjective.diff.error.density(DTM[niveau.group=="medium"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTM[niveau.group=="medium"]))
plot.subjective.diff.error.density(DTM[niveau.group=="good"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTM[niveau.group=="good"]))

``` 

##Per group, sensory task

```{r platytime.subjective.difficulty.group.sensory, echo=FALSE} 

plot.subjective.diff.error.density(DTS[niveau.group=="bad"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTS[niveau.group=="bad"]))
plot.subjective.diff.error.density(DTS[niveau.group=="medium"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTS[niveau.group=="medium"]))
plot.subjective.diff.error.density(DTS[niveau.group=="good"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTS[niveau.group=="good"]))
``` 

##Per group, logical task

```{r platytime.subjective.difficulty.group.logical, echo=FALSE} 
plot.subjective.diff.error.density(DTL[niveau.group=="bad"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTL[niveau.group=="bad"]))
plot.subjective.diff.error.density(DTL[niveau.group=="medium"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTL[niveau.group=="medium"]))
plot.subjective.diff.error.density(DTL[niveau.group=="good"])
summary(glm(error.subj.diff.mise~timeNorm + obj.diff,data = DTL[niveau.group=="good"]))
```

#Link between d(t-1) and error


```{r previous.diff.and.error, echo=FALSE} 

#Plot la courbe de diff pour un joueur
plot.diff.curve.confidence <- function (DT,title){
  if(nrow(DT) == 0)
    return()
  df <- data.frame(time=DT$action_de_jeu,
                   difficulty=DT$difficulty,
                   bet=DT$miseNorm)
  p <- ggplot(df,aes(x=time)) 
  p <- p + geom_step(aes(y=bet,colour="Bet"))
  
  if(length(DT$obj.diff) > 0)
    p <- p + geom_step(aes(y=DT$obj.diff,colour="Objective Difficulty"))
  else
    p <- p + geom_step(aes(y=difficulty,colour="Difficulty parameter"))
  
  p <- p + geom_step(aes(y=DT$est.confidence.norm,colour="Estimated Confidence"))
 
  p <- p + ylim(0, 1)
  p <- p + scale_colour_manual(
    values = c("Difficulty parameter" = "red",
               "Objective Difficulty" = "red",
               "Estimated Confidence" = "green",
               "Bet" = "blue"))
  p <- p  +  ggtitle(title);
  print(p)  
}

plot.random.diff.curve.confidence<- function (DT,title){
  player = sample(unique(DT[niveau.group == "bad"],by="IDjoueur")$IDjoueur,1)
  plot.diff.curve.confidence(DT[IDjoueur == player],paste(title,"bad"))
  player = sample(unique(DT[niveau.group == "medium"],by="IDjoueur")$IDjoueur,1)
  plot.diff.curve.confidence(DT[IDjoueur == player],paste(title,"medium"))
  player = sample(unique(DT[niveau.group == "good"],by="IDjoueur")$IDjoueur,1)
  plot.diff.curve.confidence(DT[IDjoueur == player],paste(title,"good"))
   
}

plot.random.diff.curve.confidence(DTM,"Motor")
summary(glm(error.subj.diff.mise~est.confidence.norm,data = DTM))
plot.random.diff.curve.confidence(DTS,"Sensory")
summary(glm(error.subj.diff.mise~est.confidence.norm,data = DTS))
plot.random.diff.curve.confidence(DTL,"Logical")
summary(glm(error.subj.diff.mise~est.confidence.norm,data = DTL))

```

```{r test, echo=FALSE} 
p <- lmer(error.subj.diff.mise ~ est.confidence.norm + (1 | IDjoueur), data=DTAll)
summary(p)

plot.p <- function (DT,title){
  if(nrow(DT) == 0)
    return()
  df <- data.frame(time=DT$action_de_jeu,
                   difficulty=DT$difficulty,
                   bet=DT$miseNorm)
  p <- ggplot(df,aes(x=time)) 
  p <- p + geom_step(aes(y=bet,colour="Bet"))
  
  if(length(DT$obj.diff) > 0)
    p <- p + geom_step(aes(y=DT$obj.diff,colour="Objective Difficulty"))
  else
    p <- p + geom_step(aes(y=difficulty,colour="Difficulty parameter"))
  
  p <- p + geom_step(aes(y=DT$est.confidence.norm,colour="Estimated Confidence"))
 
  p <- p + ylim(0, 1)
  p <- p + scale_colour_manual(
    values = c("Difficulty parameter" = "red",
               "Objective Difficulty" = "red",
               "Estimated Confidence" = "green",
               "Bet" = "blue"))
  p <- p  +  ggtitle(title);
  print(p)  
}

plot.p <- function (DT,title){
  player = sample(unique(DT[niveau.group == "bad"],by="IDjoueur")$IDjoueur,1)
  plot.diff.curve.confidence(DT[IDjoueur == player],paste(title,"bad"))
  player = sample(unique(DT[niveau.group == "medium"],by="IDjoueur")$IDjoueur,1)
  plot.diff.curve.confidence(DT[IDjoueur == player],paste(title,"medium"))
  player = sample(unique(DT[niveau.group == "good"],by="IDjoueur")$IDjoueur,1)
  plot.diff.curve.confidence(DT[IDjoueur == player],paste(title,"good"))
   
}

plot.p(DTM,"Motor")
summary(lmer(error.subj.diff.mise ~ est.confidence.norm + (1 | IDjoueur), data=DTM))
plot.p(DTS,"Sensory")
summary(lmer(error.subj.diff.mise ~ est.confidence.norm + (1 | IDjoueur), data=DTS))
plot.p(DTL,"Logical")
summary(lmer(error.subj.diff.mise ~ est.confidence.norm + (1 | IDjoueur), data=DTL))

```
```{r test2, echo=FALSE} 
#------------------------------------------------------------------------
#        MODELING SUBJECTIVE DIFFICULTY ON CONFIDENCE (NOT BET)
#------------------------------------------------------------------------
# #adding error between subjective difficulty and objective difficulty
# DTAll$subj.diff.confiance = 1 - DTAll$confianceNorm;
# DTAll$error.subj.diff.confiance = DTAll$subj.diff.confiance - DTAll$obj.diff
# DTAll <- DTAll[,error.subj.diff.confiance.mean:=mean(error.subj.diff.confiance),by=IDjoueur]
# 
# #evaluating confidence as a damped over time sum of win and fails;
# #each win and fail importance based on objective difficulty at that time
# id = DTAll$IDjoueur; # tmp vector faster to read
# cur.confidence = 0;
# cur.confidence.liss = 0;
# lastID <- id[1];
# est.confidence <- numeric(nrow(DTAll))
# est.confidence[1] = 0;
# obj.diff = DTAll$obj.diff
# alpha <- 0.9
# i = 1
# for(i in 2:nrow(DTAll)){
#   if(id[i] != lastID){
#     cur.confidence.liss = 0;
#   }else{
#     if(gagnant[i-1]){
#       cur.confidence = obj.diff[i-1];
#     }else{
#       cur.confidence = -(1 - obj.diff[i-1]);
#     }
#     cur.confidence.liss <- alpha * cur.confidence.liss + cur.confidence;
#   }
#   lastID <- id[i];
#   est.confidence[i] <- cur.confidence.liss;
# }
# 
# DTAll$est.confidence = est.confidence;
# DTAll$est.confidence.norm = exp(DTAll$est.confidence) / (1+exp(DTAll$est.confidence));
# 
# #update DTM DTS and DTL
# DTM <- DTAll[which(DTAll$nom_du_jeu=="Motrice"),]
# DTL <- DTAll[which(DTAll$nom_du_jeu=="Logique2"),]
# DTS <- DTAll[which(DTAll$nom_du_jeu=="Sensoriel"),]
# 
# ####tests
# plot()

```
