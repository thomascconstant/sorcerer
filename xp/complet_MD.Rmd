---
title: "Rapport données expérimentations pilotes"
output: pdf_document
---

```{r include = FALSE}
#setwd("C:/Users/Thomas Constant/Source/Repos/sorcerer/xp")
#install.packages("rmarkdown")
```


```{r include = FALSE}
#install.packages("data.table")
require(data.table)
```


```{r echo=FALSE}
#----------------------------------- configuration
useMotrice = TRUE
useSensorielle = TRUE
useLogique = TRUE
drawLogit = TRUE
removeTenFirst = FALSE
file = "./log_thomas.txt"
file = "./log_thomas_correct_motrice.txt"

#---------------------------------- fonctions

addVariables <- function(DTLoc,trace = FALSE,titre="noTitle"){
  
  #echec au lieu de succes pour diff c'est mieux
  DTLoc$perdant <- 1-DTLoc$gagnant;
  
  #normalisation de la mise
  DTLoc$miseNorm <- DTLoc$mise / 7;
  
  #difficulte évaluée par le joueur
  DTLoc$evalDiff <- 1 - DTLoc$miseNorm;
  
  #On ajoute une colonne de la difficulte estimee, a partir d'un 
  #logit de la difficulte supposée sur l'échec constaté
  mylogit <- glm(perdant ~ difficulty, data = DTLoc, family = "binomial"(link = "logit"))
  sample = data.frame(difficulty=DTLoc$difficulty)
  DTLoc$estDiff =  predict(mylogit, newdata = sample, type = "response")
  
  if(trace){
    sample = data.frame(difficulty=seq(0, 1, 0.05))
    newres = predict(mylogit, newdata = sample, type = "response")
    plot(DTLoc$difficulty, DTLoc$perdant, main=titre, xlab="difficulty",  ylab="perdant",  col=rgb(0,100,0,100,maxColorValue=255))
    points(data.frame(sample,newres), type="o")
  }
  
  #erreur d'estimation de la difficulte par le joueur (exces de confiance ?)
  DTLoc$erreurdiff <- DTLoc$evalDiff - DTLoc$estDiff;
  
  #nombre de fail consecutifs
  DTNbFail <- DTLoc[1,]
  nbFailCpt = DTLoc[1,perdant]
  DTNbFail <- cbind(DTNbFail,data.table(nbFail=nbFailCpt))

  for(i in 2:nrow(DTLoc)){
    if(DTLoc[i,gagnant] == 0){
      nbFailCpt = nbFailCpt+1;
    }else{
      nbFailCpt = 0;
    }
    DTNbFail <- rbind(DTNbFail,cbind(DTLoc[i,],data.table(nbFail=nbFailCpt)))
  }
  DTLoc <- DTNbFail
  
  #nombre de wins consecutifs
  DTNbWin <- DTLoc[1,]
  nbWinCpt = DTLoc[1,gagnant]
  DTNbWin <- cbind(DTNbWin,data.table(nbWin=nbWinCpt))
  
  for(i in 2:nrow(DTLoc)){
    if(DTLoc[i,gagnant] == 1){
      nbWinCpt = nbWinCpt+1;
    }else{
      nbWinCpt = 0;
    }
    DTNbWin <- rbind(DTNbWin,cbind(DTLoc[i,],data.table(nbWin=nbWinCpt)))
  }
  DTLoc <- DTNbWin
  
  return (DTLoc)
}

removeHeadTail <- function(DTLoc,nb,bHead=TRUE){
  #garder que les 20 derniers tours de chaque personne
  DTLoc <- as.data.table(DTLoc)
  setkey(DTLoc, IDjoueur, nom_du_jeu, action_de_jeu)
  if(bHead)
    DTLoc <- DTLoc[, tail(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
  else
    DTLoc <- DTLoc[, head(.SD, nrow(.SD)-nb), by = .(IDjoueur,nom_du_jeu)]
  
  
  return(DTLoc)
}

lienErreurEvalDiffFailsRepetes <- function(DTLoc,fails = TRUE,titre="title"){

  if(fails){
    fit <- aov(erreurdiff ~ nbFail, data=DTLoc)
    plot(x=DTLoc$nbFail, y=DTLoc$erreurdiff, main=titre, xlab="Nombre d'échecs consécutifs", ylab="Erreur d'estimation de la difficulté")
    TMP <- DTLoc[, .(meanDiffEstimated=mean(erreurdiff)),by=nbFail]
    TMP2 <- DTLoc[, .(varUpDiffEstimated=mean(erreurdiff)+var(erreurdiff)),by=nbFail]
    TMP3 <- DTLoc[, .(varDownDiffEstimated=mean(erreurdiff)-var(erreurdiff)),by=nbFail]
    setkey(TMP,nbFail)
    setkey(TMP2,nbFail)
    setkey(TMP3,nbFail)
    points(y=TMP$meanDiffEstimated, x=TMP$nbFail, col="red", type="o")
    points(y=TMP2$varUpDiffEstimated, x=TMP2$nbFail, col="blue", type="o")
    points(y=TMP3$varDownDiffEstimated, x=TMP3$nbFail, col="blue", type="o")
  }
  else{
    fit <- aov(erreurdiff ~ nbWin, data=DTLoc)
    plot(x=DTLoc$nbWin, y=DTLoc$erreurdiff, main=titre, xlab="Nombre de succès consécutifs", ylab="Erreur d'estimation de la difficulté")
    TMP <- DTLoc[, .(meanDiffEstimated=mean(erreurdiff)),by=nbWin]
    TMP2 <- DTLoc[, .(varUpDiffEstimated=mean(erreurdiff)+var(erreurdiff)),by=nbWin]
    TMP3 <- DTLoc[, .(varDownDiffEstimated=mean(erreurdiff)-var(erreurdiff)),by=nbWin]
    setkey(TMP,nbWin)
    setkey(TMP2,nbWin)
    setkey(TMP3,nbWin)
    points(y=TMP$meanDiffEstimated, x=TMP$nbWin, col="red", type="o")
    points(y=TMP2$varUpDiffEstimated, x=TMP2$nbWin, col="blue", type="o")
    points(y=TMP3$varDownDiffEstimated, x=TMP3$nbWin, col="blue", type="o")
  }

  return(fit)
}
```

```{r echo=FALSE}
#---------------------------------- traitement

#Prepa plot
#attach(mtcars)
#par(mfrow=c(5,3))

#on recup les données
csv.data <- read.csv(file,header=TRUE,sep=";")
```

<h2>Cadre des expérimentations pilotes</h2>
Les expérimentations pilotes ont pu être menés du 6 au 10 septembre, dans les mêmes conditions que celles prévues pour les expérimentations finales, à savoir dans les locaux du Living Lab auprès du public cible. 
Sur cette période, 32 personnes ont participé aux expérimentations, mais seulement 8 d'entres elles ont pu tester la version finalisée du jeu (le prototype ayant évolué au cours de ces expérimentations). Ces huit personnes ont testé les trois jeux de manière aléatoire (pour éviter tout effet d'ordre et de fatigue), réalisant 30 tours de jeu pour chaque tâche. Au total, nous obtenons 240 observations pour un jeu, soit 720 observations recouvrant l'ensemble des types de difficulté.

Pour ces expérimentations, les participants ont pu jouer aux versions finales des trois épreuves, chacune recouvrant un type de difficulté. Pour chaque type, la difficulté évolue suivant si le joueur est en condition d'échec ou de réussite, et non une courbe prédéfinie. Autrement dit, la difficulté augmente lorsque le joueur gagne ; puis baisse lorsque le joueur perd.

Pour un joueur identifié, nous nous focalisons sur les données suivantes : 

la mise, révélant leur confiance vis-à-vis de leur action de jeu ;

le tour de jeu, spécifiant la position du joueur au cours de la progression (allant de 1, début du jeu, à 30, dernier tour de jeu) ;

la difficulté du jeu à un tour de jeu donné (comprise entre 0 -facile- et 1 -très difficile-) ;

l'état du joueur en sortie de tour, à savoir s'il est gagnant (1) ou perdant (0).

Une première étape d'analyse des données récupérée consiste à vérifier si la difficulté du jeu est calibrée avec celle vécue par les joueurs. Le calcul de cette difficulté réelle est basé sur l'observation du nombre d'échec de chaque joueur pour une difficulté donnée. Les trois figures suivantes permettent d'observer l'écart qui existe entre la difficulté a priori du jeu et celle observée lors des expérimentations, et ce pour les trois jeux.

```{r echo=FALSE}
#difficulte logique
DTL <- csv.data[which(csv.data$nom_du_jeu=="Logique2"),]
DTL <- as.data.table(DTL)
DTL <- addVariables(DTL,drawLogit,titre="Logique")
```

```{r echo=FALSE}
#difficulte sensorielle
DTS <- csv.data[which(csv.data$nom_du_jeu=="Sensoriel"),]
DTS <- as.data.table(DTS)
DTS <- addVariables(DTS,drawLogit,titre="Sensorielle")
```

```{r echo=FALSE}
#difficulte motrice
DTM <- csv.data[which(csv.data$nom_du_jeu=="Motrice"),]
DTM <- as.data.table(DTM)
DTM$difficulty <-  (DTM$difficulty)/ abs(max(DTM$difficulty)) #normalisation difficulte
DTM <- addVariables(DTM,drawLogit,titre="Motrice")
```

Une deuxième étape consiste à vérifier si l'évolution de la difficulté du jeu a un impact sur la difficulté ressentie par les joueurs, la mise servant ici de référence. L'analyse précédente a permis de pouvoir obtenir la difficulté réelle de chaque jeu, nouvelle variable qui sert dorénavant de mesure de base pour observer les variations de la difficulté ressentie par le joueur.

```{r echo=FALSE}
#creation de la table totale
DT <- data.table()
if(useLogique) DT <- rbind(DT,DTL)
if(useMotrice) DT <- rbind(DT,DTM)
if(useSensorielle) DT <- rbind(DT,DTS)

#supprimer le debut ou la fin
if(removeTenFirst)
  DT <- removeHeadTail(DT,10);

#lien erreur d'eval diff (esces confiance ?) et fails ou succes répétés
fit <- lienErreurEvalDiffFailsRepetes(DT,TRUE,"Tous les jeux")
summary(fit)
fit <- lienErreurEvalDiffFailsRepetes(DT,FALSE,"Tous les jeux")
summary(fit)
```

```{r echo=FALSE}
fit <- lienErreurEvalDiffFailsRepetes(DTL,TRUE,"Logique")
summary(fit)
fit <- lienErreurEvalDiffFailsRepetes(DTL,FALSE,"Logique")
summary(fit)
```

```{r echo=FALSE}
fit <- lienErreurEvalDiffFailsRepetes(DTM,TRUE,"Motrice")
summary(fit)
fit <- lienErreurEvalDiffFailsRepetes(DTM,FALSE,"Motrice")
summary(fit)
```

```{r echo=FALSE}
fit <- lienErreurEvalDiffFailsRepetes(DTS,TRUE,"Sensorielle")
summary(fit)
fit <- lienErreurEvalDiffFailsRepetes(DTS,FALSE,"Sensorielle")
summary(fit)
```



